package com.poco.PoCoRuntime;

import java.util.HashMap;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Root policy that defers all decisions to its single child Policy. Created so that we can
 * test the code generated by the compiler before its able to parse/codegen tree-defining policies.
 */

/**
 * Root policy that defers all decisions to its single child Policy. Created so
 * that we can test the code generated by the compiler before its able to
 * parse/codegen tree-defining policies.
 */
public class DummyRootPolicy {
    private Stack<String> monitoringEvents;
    private Policy child;
    public Stack<String>   promotedEvents;
    public HashMap<String,String> closure;

    public DummyRootPolicy(Policy child) {
        this.child = child;
        this.monitoringEvents = new Stack<>();
        this.promotedEvents   = new Stack<>();
        this.closure  = new HashMap<String, String>();
    }

    public void setChild(Policy child) {
        this.child = child;
    }

    /**
     * AspectJ calls this method on any attempted action.
     *
     * @param event
     *            security-relevant action caught by AspectJ
     */
    public void queryAction(Event event) {
        if (event.eventType == null || event.eventType !="Result") {
	    monitoringEvents.push(event.getSignature());
	}
        SRE result = child.query(event); 
        //when accept is false, the returned SRE value is NULL
        if (result == null) {
            monitoringEvents.pop();
            System.exit(-1);
	    //return;
        }

        // For debugging purposes:
		/*
		 * System.out.format("Root policy queried with event: \"%s\"\n",
		 * event.getSignature()); if (result.getPositiveRE() != null)
		 * System.out.format("Child policy returned +`%s'\n",
		 * result.positiveRE()); else if(result.getNegativeRE() != null)
		 * System.out.format("Child policy returned -`%s'\n",
		 * result.negativeRE()); else {//Neutral case which means should be okay
		 * System.out.println("Child policy returned Neutral"); }
		 */
        boolean posMatch = false;
        boolean negMatch = false;

        if (result.positiveRE().length() > 0) {
            String resultPos =  result.positiveRE();
	    String reg       = "(.*)(\\$\\$(.+)\\$\\$)(.*)";
	    Pattern pattern  = Pattern.compile(reg);
	    Matcher matcher  = pattern.matcher(resultPos);
	    boolean needUpdate = matcher.find();
	    while(needUpdate){
		//need delete (, otherwise cause issues.
		String replaceStr = closure.get(matcher.group(3).trim());
		if(replaceStr.indexOf('(') != -1)
		    replaceStr = replaceStr.substring(0, replaceStr.indexOf('('));
		    resultPos = resultPos.replace(matcher.group(2).trim(), replaceStr);
		    matcher  = pattern.matcher(resultPos);
		    needUpdate = matcher.find();
		}
		posMatch= true;
		boolean promoted = false;
		if (monitoringEvents.peek().contains(resultPos)) 
			promoted = true;
		if (promoted) {
		    //System.out.println("the action is allowed");
		    monitoringEvents.pop();
		} else {
		    try {
			//System.out.println("the action will be promoted");
			String methodname=resultPos;
			int index = resultPos.indexOf('(');
			if(index > -1)
			    methodname = resultPos.substring(0, index);
			promotedEvents.push(methodname.trim());
			Promoter.Reflect(resultPos);
		    } catch (Exception ex) {
			ex.printStackTrace();
		}
	    }
        }

        if(!posMatch) {
	    if (result.negativeRE().length() > 0) {
	    // if already on stack, show System.exit(-1);
	    	if(monitoringEvents!=null && monitoringEvents.peek().contains(result.negativeRE().toString())) {
		    monitoringEvents.pop();
		    negMatch = true;
		} 
	    }
	}
        if (posMatch) 
            return;
        if (negMatch) 
            System.exit(-1);
    }
    
    public void updateClosure(String key, String value) {
	if(closure.containsKey(key))
    	    closure.remove(key);
    	closure.put(key, value);
    }
}
