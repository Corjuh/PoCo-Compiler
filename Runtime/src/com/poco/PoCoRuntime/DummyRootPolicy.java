package com.poco.PoCoRuntime;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Root policy that defers all decisions to its single child Policy. Created so that we can
 * test the code generated by the compiler before its able to parse/codegen tree-defining policies.
 */

/**
 * Root policy that defers all decisions to its single child Policy. Created so
 * that we can test the code generated by the compiler before its able to
 * parse/codegen tree-defining policies.
 */
public class DummyRootPolicy {
    private Stack<String> monitoringEvents;
    private Policy child;

    public DummyRootPolicy(Policy child) {
        this.child = child;
        this.monitoringEvents = new Stack<>();
    }

    public void setChild(Policy child) {
        this.child = child;
    }

    /**
     * AspectJ calls this method on any attempted action.
     *
     * @param event
     *            security-relevant action caught by AspectJ
     */
    public void queryAction(Event event) {
        // TODO: Do more than allow an action or halt
        SRE result = child.query(event);

        monitoringEvents.push(event.getSignature());

        //when accept is false, the returned SRE value is NULL
        if (result == null) {
            monitoringEvents.pop();
            System.exit(-1);
//			return;
        }

        // For debugging purposes:
		/*
		 * System.out.format("Root policy queried with event: \"%s\"\n",
		 * event.getSignature()); if (result.getPositiveRE() != null)
		 * System.out.format("Child policy returned +`%s'\n",
		 * result.positiveRE()); else if(result.getNegativeRE() != null)
		 * System.out.format("Child policy returned -`%s'\n",
		 * result.negativeRE()); else {//Neutral case which means should be okay
		 * System.out.println("Child policy returned Neutral"); }
		 */
        boolean posMatch = false;
        boolean negMatch = false;

        if (result.positiveRE().length() > 0) {
            boolean promoted = false;

            //if the monitoringEvent is Result, it should be popped on the stack,
            //since we already get the result
            if(!monitoringEvents.empty())
                if(event.eventType!= null && event.eventType.equals("Result"))
                    monitoringEvents.pop();

            if(monitoringEvents.peek().contains(result.positiveRE().toString())) {
                promoted = true;
            }
            if (promoted) {
                System.out.println("the action is allowed");
                monitoringEvents.pop();
            } else {
                try {
                    Promoter.Reflect(result.positiveRE());
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }

        if (result.negativeRE().length() > 0) {
            // if already on stack, show System.exit(-1);
            Pattern negPat = Pattern.compile(result.negativeRE());
            Matcher negMatcher = negPat.matcher(event.getSignature());
            negMatch = negMatcher.find();
        }
        if (posMatch) {
            return;
        }
        if (negMatch) {
            System.exit(-1);
        }
        // Placeholder for promoting a different action other than triggering
        // event
    }
}
