package com.poco.PoCoRuntime;

        import java.util.ArrayList;
        import java.util.Iterator;

/**
 * Represents a PoCo policy (i.e. one that does not define policy trees). Code generated by compiler will
 * create subclasses of Policy with constructors that configure the root execution object.
 */
public abstract class Policy extends EventResponder implements Queryable, Matchable {
    protected ArrayList<Policy> children = new ArrayList<>();
    protected AbstractExecution rootExecution;
    private   String strategy = "";
    protected String policyName = "";

    public String getPolicyName() {
        return this.policyName;
    }

    public Policy() {

    }

    public void setPolicyName(String policyName) {
        this.policyName = policyName;
    }

    public Policy(String policyName) {
        this.policyName = policyName;
    }

    public AbstractExecution getRootExecution() {
        return rootExecution;
    }

    public void setRootExecution(AbstractExecution rootExecution) {
        this.rootExecution = rootExecution;
    }

    @Override
    public boolean accepts(Event event) {
        //1. check if this policy is queried or not, if so return the queried result
        if(DataWH.isQueried(this.policyName))  {
            return DataWH.getAppectVal(policyName);
        }
        else {
            //if this policy is a leaf policy that does not have any policy as children
            if(children.size() ==0) {
                if(rootExecution.accepts(event)) {
                    return true;
                }else {
                    //if not accept, update the DataWH so that it will not check again
                    DataWH.queryRes.put(this.policyName, new QueryResult(false, null));
                    return false;
                }
            }
            else {
                //if this policy is composed with sub-policies, any sub-policies accepts
                //it will return true
                for(Iterator<Policy> it = children.iterator(); it.hasNext(); ) {
                    if(it.next().accepts(event))
                        return true;
                }
                //otherwise, update the DataWH and return false
                DataWH.queryRes.put(this.policyName, new QueryResult(false, null));
                return false;
            }
        }
    }

    @Override
    public SRE query(Event event) {
        //1. check if this policy is queried or not, if so return the queried result
        if(DataWH.isQueried(this.policyName))  {
            return DataWH.queryRes.get(this.policyName).getSREResult();
        }
        else  { //2. otherwise, query this policy, store the result and return the result
            //if this policy is a leaf policy that does not have any policy as children
            if(children.size() ==0) {
                SRE sreResult = rootExecution.query(event);
                DataWH.queryRes.put(policyName, new QueryResult(true,sreResult));
                return sreResult;
            } else {
                SRE[] sreResults = new SRE[children.size()];
                int i=0;
                for(Iterator<Policy> it = children.iterator(); it.hasNext();i++) {
                    String policyName = it.next().getPolicyName();
                    if(DataWH.isQueried(policyName)) {
                        sreResults[i]=DataWH.getResultSRE(policyName);
                    }
                    else  {
                        //no need to store result here, it will be done at its base case
                        sreResults[i] =it.next().query(event);
                    }
                }
                SRE temp = SREUtil.performBOPs(this.strategy,sreResults);
                DataWH.queryRes.put(policyName, new QueryResult(true,temp));
                return temp;
            }
        }
    }

    @Override
    public String toString() {
        return "Policy [rootExecution=" + rootExecution + "]";
    }
}
