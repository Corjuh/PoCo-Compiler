package com.poco.PoCoRuntime;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * Represents a PoCo policy (i.e. one that does not define policy trees). Code
 * generated by compiler will create subclasses of Policy with constructors that
 * configure the root execution object.
 */
public abstract class Policy extends EventResponder implements Queryable,
        Matchable {
    protected ArrayList<Policy> children = new ArrayList<>();
    protected AbstractExecution rootExecution;

    // used to record the query status of the policy
    protected boolean isQueried;

    // used to store the quereid result
    protected SRE queriedResult;
    protected boolean isAccept;

    public SRE getQueriedResult() {
        return queriedResult;
    }

    public void setQueriedResult(SRE queriedResult) {
        this.queriedResult = queriedResult;
    }

    public Policy() {
        isQueried = false;
        isAccept = false;
        queriedResult = null;
    }

    public boolean isQueried() {
        return isQueried;
    }

    public void setIsQueried(boolean isQueried) {
        this.isQueried = isQueried;
    }

    public void clearIsQueried() {
        if (children.size() > 0) {
            for (Iterator<Policy> it = children.iterator(); it.hasNext();) {
                it.next().clearIsQueried();
            }
        }
        this.isQueried = false;
    }

    public AbstractExecution getRootExecution() {
        return rootExecution;
    }

    public void setRootExecution(AbstractExecution rootExecution) {
        this.rootExecution = rootExecution;
    }

    @Override
    public boolean accepts(Event event) {
        if (this.isQueried) {
            return this.isAccept;
        } else {
            if (children.size() > 0) {
                for (Iterator<Policy> it = children.iterator(); it.hasNext();)
                    it.next().accepts(event);
            }

            if (rootExecution.accepts(event)) {
                return true;
            } else {
                // if not accept, update the query state so that it will not
                // check again
                this.isQueried = true;
                this.isAccept = false;
                return false;
            }
        }
    }

    @Override
    public SRE query(Event event) {
        // 1. check if this policy is queried or not, if so return the queried
        // result
        if (this.isQueried()) {
            return this.queriedResult;
        } else {
            // 2. otherwise, query this policy, store the result and return the
            // result
            // query the children policies first
            if (children.size() > 0) {
                ArrayList<SRE> sreResults = new ArrayList<SRE>();
                for (Iterator<Policy> it = children.iterator(); it.hasNext();) {
                    Policy temp = it.next();
                    sreResults.add(temp.query(event));
                }
            }
            this.isQueried = true;
            this.isAccept = true;
            this.queriedResult = rootExecution.query(event);
            return this.queriedResult;
        }
    }

    @Override
    public String toString() {
        return "Policy [rootExecution=" + rootExecution + "]";
    }
}