package com.poco.PoCoCompiler;


import com.poco.PoCoParser.PoCoParser;
import com.poco.PoCoParser.PoCoParserBaseVisitor;
import com.poco.Extractor.Closure;
import org.antlr.v4.runtime.misc.NotNull;

import java.io.PrintWriter;
import java.sql.SQLSyntaxErrorException;
import java.util.Stack;

import com.poco.Extractor.VarTypeVal;
import sun.jvm.hotspot.debugger.posix.elf.ELFSectionHeader;

/**
 * Generates the Java code to create a PoCoPolicy object representing
 * the parsed PoCo policy.
 */
public class PolicyVisitor extends PoCoParserBaseVisitor<Void> {
    private final int indentLevel;
    private final PrintWriter out;

    private int executionNum;
    private Stack<String> executionNames;

    private int exchangeNum;
    private String currentExchange;
    private boolean isReturnValue;

    private int matchsNum;
    private Stack<String> matchsNames;

    private int matchNum;
    private String currentMatch;

    private Closure closure;

    private String currentAction;
    private int sreNum;

    private int actionNum;

    private boolean matchRHS    = false;
    private boolean hasAsterisk = false;
    private boolean hasPlus     = false;

    /**
     * Constructor
     *
     * @param out         output stream to write to (a PrintWriter-wrapped Java or AspectJ file)
     * @param indentLevel base indent level for all code generated by PolicyVisitor
     */
    public PolicyVisitor(PrintWriter out, int indentLevel, Closure closure1) {
        this.out = out;
        this.indentLevel = indentLevel;

        // Initialize execution data structures
        this.executionNum = 0;
        this.executionNames = new Stack<>();

        // Initialize exchange data structures
        this.exchangeNum = 0;
        this.currentExchange = null;
        this.isReturnValue = false;

        // Initialize Matchs data structures
        this.matchsNum = 0;
        this.matchsNames = new Stack<>();

        // Initialize Match data structures
        this.matchNum = 0;
        this.currentMatch = null;

        // Initialize SRE data structures
        this.currentAction = null;
        this.sreNum = 0;

        this.actionNum = 0;

        this.closure = closure1;
    }

    /**
     * Outputs one line of Java/AspectJ code to the out object (always ends in newline).
     *
     * @param indent indent level of current line (relative to the existing indent level)
     * @param text   code to write out (printf style formatting used)
     * @param args   printf-style arguments
     */
    private void outLine(int indent, String text, Object... args) {
        outPartial(indent, text, args);
        outPartial(-1, "\n");
    }

    /**
     * Outputs Java/AspectJ code without appending newline. Use a negative indent value to
     * disable indents.
     *
     * @param indent indent level (relative to existing indent level), or negative to disable indents
     * @param text   code to write out (printf style formatting used)
     * @param args   printf-style arguments
     */
    private void outPartial(int indent, String text, Object... args) {
        if (indent >= 0) {
            int trueIndent = (indent + indentLevel) * 4;

            for (int i = 0; i < trueIndent; i++) {
                out.format(" ");
            }
        }
        out.format(text, args);
    }

    /**
     * Generates code for class representing a PoCo policy. This is the first visit method called.
     *
     * @param ctx
     * @return
     */
    @Override
    public Void visitPocopol(@NotNull PoCoParser.PocopolContext ctx) {
        String policyName = ctx.id().getText();

        outLine(0, "class %s extends Policy {", policyName);
        outLine(1, "public %s() {", policyName);
        outLine(2, "try {");
        executionNames.push("ROOT");
        visitChildren(ctx);
        executionNames.pop();
        outLine(2, "} catch (PoCoException pex) {");
        outLine(3, "System.out.println(pex.getMessage());");
        outLine(3, "pex.printStackTrace();");
        outLine(3, "System.exit(-1);");
        outLine(2, "}");
        outLine(1, "}");
        outLine(0, "}");

        return null;
    }

    @Override
    public Void visitParamlist(@NotNull PoCoParser.ParamlistContext ctx) {
        // TODO: Support actual policy parameters (as references to policy objects)

        visitChildren(ctx);

        return null;
    }

    @Override
    public Void visitExecution(@NotNull PoCoParser.ExecutionContext ctx) {
        // TODO: Support non-sequential executions
        if(ctx.exch() == null) {
            // Get modifier of execution (i.e. + or *), if any
            if (ctx.ASTERISK() != null)
                hasAsterisk = true;
            else if (ctx.PLUS() != null)
                hasPlus = true;
            else {
                hasAsterisk = false;
                hasPlus     = false;
            }
            visitChildren(ctx);
        }
        else if (ctx.exch() != null) {
            String executionName = "exec" + executionNum++;
            String parentExecutionName = executionNames.peek();
            String modifier = "none";

            // Get modifier of execution (i.e. + or *), if any
            if (hasAsterisk)
                modifier = "*";
            else if (hasPlus)
                modifier = "+";


            // This execution becomes the parent of all children
            executionNames.push(executionName);

            // CODE GENERATION:
            // Declare new execution variable and initialize it
            outLine(3, "SequentialExecution %s = new SequentialExecution(\"%s\");", executionName, modifier);

            // Visit children, who will add themselves as children to this execution.
            visitChildren(ctx);

            // Add this execution as a child to the parent
            /*if (parentExecutionName == "ROOT") {
                outLine(3, "rootExecution = %s;", executionName);
            } else {
                outLine(3, "%s.addChild(%s);", parentExecutionName, executionName);
            }*/
            outLine(3, "root.addChild(%s);", executionName);

            // All children have been visited. Remove from stack.
            executionNames.pop();
        } else {
            // Empty execution wrapping an exchange object
            visitChildren(ctx);
        }

        return null;
    }

    @Override
    public Void visitExch(@NotNull PoCoParser.ExchContext ctx) {
        // Create Exchange object
        String exchangeName = "exch" + exchangeNum++;
        // Visit children to flesh out the exchange object
        currentExchange = exchangeName;

        outLine(3, "Exchange %s = new Exchange();", exchangeName);

        // The code for the match object is not generated here unless the match portion is a wildcard
        boolean isWildcardMatch = (ctx.INPUTWILD() != null);
        if (isWildcardMatch) {
            //String matchName = "match" + matchNum++;
            //outLine(3, "Match %s = new Match(%s);", matchName, "\"%\"");
            //outLine(3, "%s.addMatcher(%s);", exchangeName, matchName);
            matchRHS = true;
            visitSre(ctx.sre());
            matchRHS = false;
        }

        // Visit children to flesh out the exchange object
        //currentExchange = exchangeName;

        if (!isWildcardMatch) {
            visitChildren(ctx.matchs());
        }

        // Let the child SRE know it's a return value, so that it attaches itself to this exchange
        isReturnValue = true;
        visitSre(ctx.sre());
        isReturnValue = false;

        currentExchange = null;

        // Add Exchange to containing execution
        outLine(3, "%s.addChild(%s);", executionNames.peek(), exchangeName);

        return null;
    }

    @Override
    public Void visitMatchs(@NotNull PoCoParser.MatchsContext ctx) {
        // If the child node is a Match object, this Matchs object is unnecessary
        boolean hasMatch = (ctx.match() != null);
        if (!hasMatch) {
            String matchsName = "matchs" + matchsNum++;

            // Does this contain a &&, ||, or ! operator?
            String operator = "";
            if (ctx.BOOLBOP() != null) {
                operator = ctx.BOOLBOP().getText();
            } else if (ctx.BOOLUOP() != null) {
                operator = ctx.BOOLUOP().getText();
            }

            // Create matchs object
            outLine(3, "Matchs %s = new Matchs(%s);", matchsName, operator);

            // Visit children
            matchsNames.push(matchsName);
            visitChildren(ctx);
            matchsNames.pop();

            // Add to parent
            if (matchsNames.empty()) {
                // Add this object directly to the parent Exchange
                outLine(3, "%s.addMatcher(%s);", currentExchange, matchsName);

            } else {
                // Add this object as a child to the parent matchs
                outLine(3, "%s.addChild(%s);", matchsNames.peek(), matchsName);
            }
        } else {
            // This matchs simply wraps a match object. No need to create a matchs object
            visitChildren(ctx);
        }

        return null;
    }

    @Override
    public Void visitMatch(@NotNull PoCoParser.MatchContext ctx) {
        // Create match object
        String matchName = "match" + matchNum++;
        outLine(3, "Match %s = new Match();", matchName);

        // TODO: Handle case when something other than an ire is in a match object
        // Visit children
        currentMatch = matchName;
        visitChildren(ctx);
        currentMatch = null;

        // Add to parent
        if (matchsNames.empty()) {
            // Add match object to parent exchange
            outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
        } else {
            // Add match object to parent matchs
            outLine(3, "%s.addChild(%s);", matchsNames.peek(), matchName);
        }

        return null;
    }

    @Override
    public Void visitIre(@NotNull PoCoParser.IreContext ctx) {

        String actionresultname;
        String reString;


        boolean isAction = false;

        if (ctx.ACTION() != null) {
            isAction = true;
        } else {
            isAction = false;  //is result
        }

        if (ctx.re(0) != null) {
            if (ctx.re(0).qid() != null) {
                reString = loadFromClosure(ctx.re(0).qid().getText());
                if (reString == null)
                    reString = ctx.re(0).qid().getText();
            } else
                reString = ctx.re(0).getText();

            if (ctx.re(0).AT() != null) {
                if (ctx.re(0).id() != null) {
                    if (closure != null) {
                        VarTypeVal val = closure.loadClosure(ctx.re(0).id().getText());
                        val.setReContext(ctx.re(0));
                        closure.updateClosure(ctx.re(0).id().getText(), val);

                    }
                } else
                    throw new NullPointerException("No such var exist.");
            }

            if (isAction) {
                outLine(3, "%s.setAction(true)",currentMatch);
                outLine(3, "%s.setResult(false)",currentMatch);
                outLine(3, "%s.setMatchString(\"%s\")", currentMatch, scrubString(reString));
            } else {
                String reString2 = null;
                if (ctx.re(1).qid() != null) {
                    reString2 = loadFromClosure(ctx.re(1).qid().getText());
                    if (reString2 == null)
                        reString2 = ctx.re(1).qid().getText();
                } else
                    reString2 = ctx.re(1).getText();


                outLine(3, "%s.setAction(false)",currentMatch);
                outLine(3, "%s.setResult(true)",currentMatch);
                outLine(3, "%s.setMatchString(%s)",currentMatch, scrubString(reString2));
            }
            // Add this ire's action match string to the current Match object
            //outLine(3, "%s.setMatchString(%s);", currentMatch, ctx.re(0).getText());
        }
        return null;
    }

    @Override
    public Void visitSre(@NotNull PoCoParser.SreContext ctx) {
        // TODO: Support SREs existing outside of the "return" part of an exchange
        if (matchRHS == true) {
            if (ctx.re() != null) {
                visitRe(ctx.re());
            } else if (ctx.qid() != null) {
                String str = loadFromClosure(ctx.qid().getText());
                if (str == null)
                    str = ctx.qid().getText();
                String matchName = "match" + matchNum++;
                outLine(3, "Match %s = new Match(%s);", matchName, str);
                outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
            }

        } else {
            if (ctx.NEUTRAL() != null) {
                String sreName = "sre" + sreNum++;
                outLine(3, "SRE %s = new SRE(null, null);", sreName);
                if (isReturnValue) {
                    outLine(3, "%s.setSRE(%s);", currentExchange, sreName);
                }
            } else {
                boolean positive = (ctx.PLUS() != null);
                String sreName = "sre" + sreNum++;
                String content = ctx.re().getText();
                if (positive) {
                    outLine(3, "SRE %s = new SRE(\"%s\", null);", sreName, content);
                } else {
                    outLine(3, "SRE %s = new SRE(null, \"%s\");", sreName, content);
                }
                if (isReturnValue) {
                    outLine(3, "%s.setSRE(%s);", currentExchange, sreName);
                }
            }
        }
        return null;
    }

    @Override
    public Void visitVardecl(@NotNull PoCoParser.VardeclContext ctx) {
        if (ctx.id() != null) {
            VarTypeVal varTyCal;
            if (ctx.RETYPE() != null) {
                varTyCal = new VarTypeVal(VarTypeVal.ClosureType.RE_TYPE, null, null);
            } else {
                varTyCal = new VarTypeVal(VarTypeVal.ClosureType.SRE_TYPE, null, null);
            }
            closure.addClosure(ctx.id().getText(), varTyCal);
        }

        return null;
    }

    @Override
    public Void visitRe(@NotNull PoCoParser.ReContext ctx) {
        if (matchRHS == true) {
            String matchName = "match" + matchNum++;
            outLine(3, "Match %s = new Match(%s);", matchName, ctx.getText());
            outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
        } else {
            if (ctx.rewild() != null) {
                // will only need monitor the negative sre on the RHS
            }
            if (ctx.qid() != null) {
                VarTypeVal val = closure.loadClosure(ctx.id().getText());
                VarTypeVal.ClosureType varType = val.getVarType();
            }

            if (ctx.AT() != null) {
                if (ctx.id() != null) {
                    if (closure != null) {
                        VarTypeVal val = closure.loadClosure(ctx.id().getText());
                        val.setReContext(ctx.re(0));
                        closure.updateClosure(ctx.id().getText(), val);

                    }
                } else
                    throw new NullPointerException("No such var exist.");
            }
        }
        return null;
    }

    private static String scrubString(String input) {
        return input.replaceAll("(%|\\$[a-zA-Z0-9\\.\\-_]+)", "");
    }


    public String loadFromClosure(String varName) {
        String strval = null;
        if (closure != null)
            if (closure.loadClosure(varName) != null)
                if (closure.loadClosure(varName).getVarType() == VarTypeVal.ClosureType.RE_TYPE &&
                        closure.loadClosure(varName).getReContext() != null)
                    strval = closure.loadClosure(varName).getReContext().getText();
                else if (closure.loadClosure(varName).getVarType() == VarTypeVal.ClosureType.SRE_TYPE &&
                        closure.loadClosure(varName).getSreContext() != null)
                    strval = closure.loadClosure(varName).getSreContext().getText();

        return strval;
    }
}
