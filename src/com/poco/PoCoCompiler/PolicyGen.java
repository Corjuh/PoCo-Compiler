package com.poco.PoCoCompiler;

import com.poco.Extractor.Closure;
import com.poco.Extractor.ParsFlgConsts;
import com.poco.PoCoParser.PoCoParser;
import com.poco.PoCoParser.PoCoParserBaseVisitor;
import org.antlr.v4.runtime.misc.NotNull;

import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Generates the Java code to create a PoCoPolicy object representing
 * the parsed PoCo policy.
 */
public class PolicyGen extends PoCoParserBaseVisitor<Void> {
    private final int indentLevel;
    private final PrintWriter out;

    private int executionNum;
    private Stack<String> executionNames;

    //use to record the current modifier for this execution,
    //since one execution can only have one exchange as children,
    //we will set the exchange has the same modifier
    //this will only be used to set the modifier attribute for exchange
    private String currentModifier;

    private int exchangeNum;
    private String currentExchange;

    private int matchsNum;
    private Stack<String> matchNames;

    private int matchNum;
    private String currentMatch;
    private Closure closure;

    private int sreNum;
    private Stack<String> sreNames;
    private String policyName = null;

    //this stack is used to flag the status when parsing arguments
    private Stack<Integer> flagStack4Arg;
    //this stack is used to flag different status related to the SRE
    private Stack<Integer> flagStack4Sre;
    //this stack is used to flag different status related to the Execution
    private Stack<Integer> flagStack4Exc;
    //this stack is used to flag different status related to the RE
    private Stack<Integer> flagStack4RE;

    private StringBuilder reBopStr;
    private StringBuilder argListStr;
    private StringBuilder policyArgStr;

    /**
     * Constructor
     *
     * @param out         output stream to write to (a PrintWriter-wrapped Java or AspectJ file)
     * @param indentLevel base indent level for all code generated by PolicyGen
     */
    public PolicyGen(PrintWriter out, int indentLevel, Closure closure) {
        this.out = out;
        this.indentLevel = indentLevel;
        // Initialize execution data structures
        this.executionNum = 0;
        this.executionNames = new Stack<>();
        // Initialize exchange data structures
        this.exchangeNum = 0;
        this.currentExchange = null;

        // Initialize Matchs data structures
        this.matchNames = new Stack<>();

        // Initialize Match data structures
        this.matchNum = 0;
        this.matchsNum = 0;
        this.currentMatch = null;

        // Initialize SRE data structures
        this.sreNum = 0;
        this.sreNames = new Stack<>();

        this.closure = closure;
        this.flagStack4Arg = new Stack<>();
        this.flagStack4Sre = new Stack<>();
        this.flagStack4Exc = new Stack<>();
        this.flagStack4RE = new Stack<>();

        argListStr = new StringBuilder();
        reBopStr = new StringBuilder();
        policyArgStr = new StringBuilder();
    }

    /**
     * Outputs one line of Java/AspectJ code to the out object (always ends in newline).
     *
     * @param indent indent level of current line (relative to the existing indent level)
     * @param text   code to write out (printf style formatting used)
     * @param args   printf-style arguments
     */
    private void outLine(int indent, String text, Object... args) {
        outPartial(indent, text, args);
        outPartial(-1, "\n");
    }

    /**
     * Outputs Java/AspectJ code without appending newline. Use a negative indent value to
     * disable indents.
     *
     * @param indent indent level (relative to existing indent level), or negative to disable indents
     * @param text   code to write out (printf style formatting used)
     * @param args   printf-style arguments
     */
    private void outPartial(int indent, String text, Object... args) {
        if (indent >= 0) {
            int trueIndent = (indent + indentLevel) * 4;
            for (int i = 0; i < trueIndent; i++)
                out.format(" ");
        }
        out.format(text, args);
    }

    /**
     * Generates code for class representing a PoCo policy. This is the first visit method called.
     *
     * @param ctx
     * @return
     */
    @Override
    public Void visitPocopol(PoCoParser.PocopolContext ctx) {
        policyName = ctx.id().getText();

        if (ctx.paramlist() != null && ctx.paramlist().getText().trim().length() > 0) {
            visitParamlist(ctx.paramlist());
            policyArgStr.deleteCharAt(policyArgStr.length() - 1);
        }

        outLine(0, "class %s extends Policy {", policyName);
        if (policyArgStr.toString().length() > 0) {
            outLine(1, "public %s(%s) {", policyName, policyArgStr);
        } else
            outLine(1, "public %s() {", policyName);

        outLine(2, "super();");
        outLine(2, "try {");
        outLine(3, "SequentialExecution rootExec = new SequentialExecution(\"none\");");
        executionNames.push("rootExec");
        visitExecution(ctx.execution());
        executionNames.pop();
        outLine(3, "rootExec.getCurrentChildModifier();");
        outLine(3, "setRootExecution(rootExec);");

        if (policyArgStr.toString().length() > 0) {
            //double percent,long interval ; Policy p1,Policy p2
            String[] args = policyArgStr.toString().split(",");
            for (String arg : args) {
                String varTyp = arg.split("\\s+")[0];
                String varName = arg.split("\\s+")[1];
                outLine(3, "DataWH.updateTyeVal(\"" + policyName + "_" + varName + "\", \"" + varTyp + "\", " + varName + ");");
            }
            policyArgStr = new StringBuilder();
        }

        outLine(2, "} catch (PoCoException pex) {");
        outLine(3, "System.out.println(pex.getMessage());");
        outLine(3, "pex.printStackTrace();");
        outLine(3, "System.exit(-1);");
        outLine(2, "}");
        outLine(1, "}");
        outLine(0, "}");
        //outLine(0, "%s policy1 = new %s();", policyName, policyName);
        //outLine(0, "root.setChild(policy1);");
        return null;
    }

    @Override
    public Void visitParamlist(PoCoParser.ParamlistContext ctx) {
        if (ctx.getText().trim().length() > 0)
            visitChildren(ctx);
        policyArgStr.append(ctx.qid().getText() + " " + ctx.id().getText() + ",");
        return null;
    }

    @Override
    public Void visitExecution(@NotNull PoCoParser.ExecutionContext ctx) {
        if (ctx.BAR() != null)          //alternation execution(e.g.,  execution_1|execution)
            handleAlterExec(ctx);
        else if (ctx.map() != null)     //handle map execution
            handleMapExec(ctx);
        else if (ctx.LPAREN() != null)  //for grouped executions but not alternation
            handleGroupedExecs(ctx);
        else {
            handleLeafExec(ctx);
        }
        return null;
    }

    private void handleLeafExec(PoCoParser.ExecutionContext ctx) {
        if (ctx.exch() != null) {
            String modifier = getModifierFlag(ctx);
            String executionName = "exec" + executionNum++;
            executionNames.push(executionName);
            outLine(3, "SequentialExecution %s = new SequentialExecution(\"%s\");", executionName, modifier);
            currentModifier = modifier;
            visitChildren(ctx);
            executionNames.pop();
            outLine(3, "%s.addChild(%s);", executionNames.peek(), executionName);
        } else {
            setModifierFlag((ctx.ASTERISK() != null), (ctx.PLUS() != null));
            visitChildren(ctx);
        }
    }

    private void handleGroupedExecs(PoCoParser.ExecutionContext ctx) {
        String modifier = getModifierFlag(ctx);
        String seqExec = "groupedExec" + executionNum++;
        executionNames.push(seqExec);
        outLine(3, "SequentialExecution %s = new SequentialExecution(\"%s\");", seqExec, modifier);
        visitChildren(ctx);
        executionNames.pop();
        outLine(3, "%s.addChild(%s);", executionNames.peek(), seqExec);
    }

    private void handleMapExec(@NotNull PoCoParser.ExecutionContext ctx) {
        String modifier = getModifierFlag();
        String executionName = "mapExec" + executionNum++;
        executionNames.push(executionName);
        outLine(3, "MapExecution %s = new MapExecution(\"%s\");", executionName, modifier);
        outLine(3, "%s.setOperator(\"%s\");", executionName, ctx.map().srebop().getText());

        //flag as mapSre so re will know how to handle it
        flagStack4Exc.push(ParsFlgConsts.isMapSre);
        visitSre(ctx.map().sre());
        flagStack4Exc.pop();

        visitExecution(ctx.map().execution());
        executionNames.pop();
        outLine(3, "%s.addChild(%s);", executionNames.peek(), executionName);
    }

    private void handleAlterExec(@NotNull PoCoParser.ExecutionContext ctx) {
        String modifier = getModifierFlag(ctx);
        String executionName = "alterExec" + executionNum++;
        executionNames.push(executionName);
        outLine(3, "AlternationExecution %s = new AlternationExecution(\"%s\");", executionName, modifier);
        visitExecution(ctx.execution(0));
        visitExecution(ctx.execution(1));
        executionNames.pop();
        outLine(3, "%s.addChild(%s);", executionNames.peek(), executionName);
    }

    @Override
    public Void visitExch(@NotNull PoCoParser.ExchContext ctx) {
        String exchangeName = "exch" + exchangeNum++;
        // Visit children to flesh out the exchange object
        currentExchange = exchangeName;
        outLine(3, "Exchange %s = new Exchange();", exchangeName);
        currentModifier = "none";

        //if is the wideCardMatch case, only need handle Sre part
        if (ctx.INPUTWILD() != null) {
            flagStack4Exc.push(ParsFlgConsts.isExchLHSWild);
            visitSre(ctx.sre());
            flagStack4Exc.pop();
        } else if (ctx.matchs() != null) {
            handleMatchsPart(ctx);
        }
        flagStack4Exc.push(ParsFlgConsts.isExchRHSSre);
        visitSre(ctx.sre());
        flagStack4Exc.pop();

        currentExchange = null;
        // Add Exchange to containing execution
        outLine(3, "%s.addChild(%s);", executionNames.peek(), exchangeName);
        outLine(3, "%s.setHasExch(true);", executionNames.peek());
        return null;
    }

    private void handleMatchsPart(@NotNull PoCoParser.ExchContext ctx) {
        String matchsName = "matchs" + matchsNum++;
        outLine(3, "Matchs %s = new Matchs();", matchsName);
        matchNames.push(matchsName);
        visitMatchs(ctx.matchs());
        outLine(3, "%s.addMatcher(%s);", currentExchange, matchsName);
        matchNames.pop();
    }

    @Override
    public Void visitMatchs(@NotNull PoCoParser.MatchsContext ctx) {
        // If it s a compounded match, then Matchs object is necessary
        if (ctx.match() == null) {
            //Step 1: get all the info about boolean values of this match
            boolean hasBooluop = (ctx.BOOLUOP() != null);
            if (hasBooluop)
                outLine(3, "%s.setNOT(true);", matchNames.peek());

            boolean hasAnd = ctx.BOOLBOP() != null && ctx.BOOLBOP().getText().equals("&&");
            boolean hasOr = ctx.BOOLBOP() != null && ctx.BOOLBOP().getText().equals("||");

            if (hasAnd || hasOr) {
                String matchsName = "matchs" + matchsNum++;
                outLine(3, "Matchs %s = new Matchs();", matchsName);
                if (hasAnd)
                    outLine(3, "%s.setAND(true);", matchsName);
                else if (hasOr)
                    outLine(3, "%s.setOR(true);", matchsName);
                matchNames.push(matchsName);
                visitChildren(ctx);
                matchNames.pop();
                outLine(3, "%s.addChild(%s);", matchNames.peek(), matchsName);
            } else {
                visitChildren(ctx);
            }
        } else {
            // If the child node is a Match object, this Matchs object is unnecessary
            visitChildren(ctx);
        }
        return null;
    }

    @Override
    public Void visitMatch(@NotNull PoCoParser.MatchContext ctx) {
        String matchName;
        if (ctx.INFINITE() != null) {
            handleInfiniteMatch(ctx);
        } else if (ctx.SUBSET() != null) {
            handleSubsetMatch(ctx);
        } else if (ctx.SREEQUALS() != null) {
            handleEqualsMatch(ctx);
        } else if (ctx.AT() != null) {
            handleAtMatch(ctx);
        } else { //ire case
            //set isMatch for ture, so match as @out[`$p'] case will be knowned as match
            flagStack4Exc.push(ParsFlgConsts.isExchMatch);
            visitChildren(ctx);
            flagStack4Exc.pop();
            currentMatch = null;
        }
        return null;
    }

    private void handleAtMatch(@NotNull PoCoParser.MatchContext ctx) {
        handleNoIreCase(ctx, "VarMatch");
    }

    private void handleInfiniteMatch(@NotNull PoCoParser.MatchContext ctx) {
        handleNoIreCase(ctx, "InfintMatch");
    }

    private void handleEqualsMatch(@NotNull PoCoParser.MatchContext ctx) {
        handleNoIreCase(ctx, "EqualsMatch");
    }

    private void handleSubsetMatch(@NotNull PoCoParser.MatchContext ctx) {
        handleNoIreCase(ctx, "SubsetMatch");
    }

    private void handleNoIreCase(@NotNull PoCoParser.MatchContext ctx, String kind) {
        String matchName = kind + matchNum++;
        outLine(3, kind + " %s = new " + kind + "(null, null);", matchName);
        visitTheMatch(ctx, matchName);
    }

    private void visitTheMatch(@NotNull PoCoParser.MatchContext ctx, String matchName) {
        currentMatch = matchName;
        flagStack4Exc.push(ParsFlgConsts.isExchMatch);
        visitChildren(ctx);
        flagStack4Exc.pop();
        currentMatch = null;
        // Add match object to parent exchange or parent matchs
        if (matchNames.empty())
            outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
        else
            outLine(3, "%s.addChild(%s);", matchNames.peek(), matchName);
    }

    @Override
    public Void visitIre(@NotNull PoCoParser.IreContext ctx) {
        String matchName = "match" + matchNum++;
        currentMatch = matchName;
        if (ctx.ACTION() != null) {
            outLine(3, "Match %s = new Match();", matchName);
            flagStack4RE.push(ParsFlgConsts.isIREAction);
            visitRe(ctx.re(0));
            flagStack4RE.pop();
        } else {
            outLine(3, "ResMatch %s = new ResMatch();", matchName);
            flagStack4RE.push(ParsFlgConsts.isIREResult);
            visitRe(ctx.re(0));
            flagStack4RE.pop();
            flagStack4RE.push(ParsFlgConsts.isIREResMatch);
            visitRe(ctx.re(1));
            flagStack4RE.pop();
        }

        if (matchNames.empty())   // Add match object to parent exchange
            outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
        else   // Add match object to parent matchs
            outLine(3, "%s.addChild(%s);", matchNames.peek(), matchName);

        return null;
    }

    @Override
    public Void visitSre(@NotNull PoCoParser.SreContext ctx) {
        if (PoCoUtils.isExchLHSWild(flagStack4Exc)) {
            if (ctx.re() != null) {
                // (+|-)`re' case
                visitRe(ctx.re());
            } else if (ctx.qid() != null) {
                //$qid case
                String varName = policyName + "_" + ctx.qid().getText().trim();
                String str = loadFromFunction(varName);
                //! function case
                if (str == null)
                    str = "$"+varName;
                String matchName = "match" + matchNum++;
                outLine(3, "Match %s = new Match(\"%s\");", matchName, str);
                outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
            } else if (ctx.NEUTRAL() != null) {
                //neutral case
                String matchName = "match" + matchNum++;
                outLine(3, "Match %s = new Match(\"*\");", matchName);
                outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
            } else if (ctx.srebop() != null) {
                // srebop(sre0,sre1) case
                LHSRewildWSreBop(ctx);
            } else {
                // handle both () case and sreuop(sre) case
                visitChildren(ctx);
            }
        } else {
            if (ctx.NEUTRAL() != null) {
                handleSreNeutral();
            } else if (ctx.PLUS() != null | ctx.MINUS() != null) {
                // (+|-)`re' case
                String sreName = "sre" + sreNum++;
                sreNames.push(sreName);
                outLine(3, "SRE %s = new SRE(null, null);", sreName);

                //Add to support the case that manipulates the return value of a method call
                if (handleSre4Up8RetVal(ctx, sreName))
                    return null;

                handlePosNegReCase(ctx, sreName);
            } else if (ctx.srebop() != null) {
                // srebop(sre0,sre1) case
                handleSreBopCase(ctx);
            } else if (ctx.sreuop() != null) {
                // sreuop(sre0) case
                handleSreUopCase(ctx);
            } else if (ctx.DOLLAR() != null) {
                //$qid case
                handleSreQidCase(ctx);
            } else if (ctx.LPAREN() != null) {
                //() case
                visitChildren(ctx);
            }
        }
        return null;
    }

    private void LHSRewildWSreBop(@NotNull PoCoParser.SreContext ctx) {
        //in such case that srebop is on the right hand side, because
        //match no such case, we can treat it as srebop, and the match
        //will match both sre(0) and sre(1)
        flagStack4RE.push(ParsFlgConsts.isReBop);
        String matchsName = "matchs" + matchsNum++;
        outLine(3, "Matchs %s = new Matchs();", matchsName);
        matchNames.push(matchsName);
        visitSre(ctx.sre(0));
        visitSre(ctx.sre(1));
        outLine(3, "%s.addMatcher(%s);", currentExchange, matchsName);
        matchNames.pop();
        flagStack4RE.pop();
    }

    private void handleSreQidCase(@NotNull PoCoParser.SreContext ctx) {
        //for qid case, currently put the qid info in the positiveRE, so when
        //SreUop is null, then we will check if it is pos or neg, when
        //SreUop is not null, then we treat pos differently
        String sreName = "sre" + sreNum++;
        String varName = policyName + "_" + ctx.qid().getText();
        if (closure != null && closure.isVarsContain(varName))
            outLine(3, "SRE %s = new SRE(\"%s\", null);", sreName, "$" + varName);
        else
            outLine(3, "SRE %s = new SRE(\"%s\", null);", sreName, closure.loadFrmFunctions(varName));

        if (!sreNames.empty())
            setSREvalue(sreNames.peek(), sreName);
        else
            outLine(3, "%s.setSRE(%s);", currentExchange, sreName);
    }

    private void handleSreUopCase(@NotNull PoCoParser.SreContext ctx) {
        String sreuopStr = null;
        if (ctx.sreuop().srecomp() != null)
            sreuopStr = "Complement";
        else if (ctx.sreuop().sreactions() != null)
            sreuopStr = "Actions";
        else if (ctx.sreuop().sreresults() != null)
            sreuopStr = "Results";
        else if (ctx.sreuop().srepos() != null)
            sreuopStr = "Positive";
        else //if(ctx.sreuop().sreneg() != null)
            sreuopStr = "Negative";

        String sreName = "uopSRE" + sreNum++;
        outLine(3, "UopSRE %s = new UopSRE(\"%s\", null);", sreName, sreuopStr);
        sreNames.push(sreName);
        visitSre(ctx.sre(0));
        sreNames.pop();
        if (!sreNames.empty())
            setSREvalue(sreNames.peek(), sreName);
    }

    private void handleSreBopCase(@NotNull PoCoParser.SreContext ctx) {
        //set flag indicate this is a srebop case, sre0 & sre1 should be added as srebop's children
        String sreName = "bopSRE" + sreNum++;
        outLine(3, "BopSRE %s = new BopSRE(\"%s\",null, null);", sreName, ctx.srebop().getText());
        sreNames.push(sreName);
        flagStack4Sre.push(ParsFlgConsts.isSreBop1);
        visitSre(ctx.sre(0));
        flagStack4Sre.pop();

        flagStack4Sre.push(ParsFlgConsts.isSreBop2);
        visitSre(ctx.sre(1));
        flagStack4Sre.pop();

        sreNames.pop();
        if (!sreNames.empty()) {
            setSREvalue(sreNames.peek(), sreName);
        } else {
            if (PoCoUtils.isExchMatch(flagStack4Exc)) {
                if (currentMatch.contains("otherMatch"))
                    outLine(3, "%s.setSre1(%s);", currentMatch, sreName);
            } else if (PoCoUtils.isExchRHSSre(flagStack4Exc)) {
                outLine(3, "%s.setSRE(%s);", currentExchange, sreName);
            }
        }
    }

    private void handlePosNegReCase(@NotNull PoCoParser.SreContext ctx, String sreName) {
        //check it is positive RE or negative RE and set the correct flag
        if ((ctx.PLUS() != null))
            flagStack4RE.push(ParsFlgConsts.isSrePosRE);
        else
            flagStack4RE.push(ParsFlgConsts.isSreNegRE);
        //parse the children
        visitChildren(ctx);
        //pop the flag
        flagStack4RE.pop();

        sreNames.pop();
        if (!sreNames.empty())
            setSREvalue(sreNames.peek(), sreName);
    }

    private boolean handleSre4Up8RetVal(@NotNull PoCoParser.SreContext ctx, String sreName) {
        if (ctx.PLUS() != null) {
            //not a function call but an object value, then is the case of update return value
            if (isPoCoObject(ctx.re().getText().trim())) {
                String objReg = "#(.+)\\{(.+)\\}";
                Pattern objPtn = Pattern.compile(objReg);
                Matcher objMth = objPtn.matcher(ctx.re().getText().trim());
                if (objMth.find()) {
                    String temp = objMth.group(2).trim();
                    if (temp.length() > 0 && !temp.startsWith("$")) {
                        outLine(3, "%s.setPositiveRE(\"%s\");", sreNames.peek(), ctx.re().getText().trim());
                        sreNames.pop();
                        if (!sreNames.empty())
                            setSREvalue(sreNames.peek(), sreName);
                        outLine(3, "%s.setSRE(%s);", currentExchange, sreName);
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private void handleSreNeutral() {
        String sreName = "sre" + sreNum++;
        if (PoCoUtils.isMapSreFlag(flagStack4Exc))
            outLine(3, "%s.setMatchSre(%s);", executionNames.peek(), sreName);
        else {
            outLine(3, "SRE %s = new SRE(null, null);", sreName);
            if (PoCoUtils.isExchRHSSre(flagStack4Exc))
                outLine(3, "%s.setSRE(%s);", currentExchange, sreName);
        }
    }

    @Override
    public Void visitRe(@NotNull PoCoParser.ReContext ctx) {
        if (ctx.getText().trim().length() == 0 || ctx.getText().trim().equals("()")) {
            ;
        } else if (PoCoUtils.isExchLHSWild(flagStack4Exc)) {
            handleREonRHS(ctx);
        } else if (ctx.LPAREN() != null && ctx.re(0) != null) {
            visitRe(ctx.re(0));
        } else if (ctx.rebop() != null) {
            handleReBopCase(ctx);
        } else if (ctx.AT() != null) { //binding variable
            visitRe(ctx.re(0));
            //handleReAtCase(ctx);
        } else if (ctx.rewild() != null) {
            if (PoCoUtils.isParsingArg(flagStack4Arg))
                argListStr.append("*,");
            else if (PoCoUtils.isIREAction(flagStack4RE) || PoCoUtils.isIREResMatch(flagStack4RE))
                outLine(3, "%s.setWildcard(true);", currentMatch);
        } else {  //leaf case of RE
            String content = "";
            if (ctx.DOLLAR() != null) {
                if (PoCoUtils.isParsingArg(flagStack4Arg)) {
                    dollarReAsArgCase(ctx.qid().getText());
                } else {
                    content = dollarReNotArgCase(ctx);
                }
            } else {
                if (ctx.object() != null) {
                    content = reIsObjCase(ctx, content);
                } else if (ctx.function() != null) {
                    content = reIsFuncCase(ctx);
                } else {
                    if (PoCoUtils.isParsingArg(flagStack4Arg)) {
                        argListStr.append(ctx.getText() + ",");
                    } else {
                        content = ctx.getText();
                    }
                }
            }
            if (PoCoUtils.isParsingArg(flagStack4Arg))
                return null;

            content = PoCoUtils.validateStr(content);

            if (PoCoUtils.isReBopFlag(flagStack4RE)) {
                reBopStr.append(content + "|");
            } else {
                //check wether the current method is a transaction method case
                if (isMethod(content)) {
                    content = handleTransCase(content, policyName);
                }
                if (PoCoUtils.isPosNegRe4SRE(flagStack4RE)) {
                    if (PoCoUtils.isSrePosRE(flagStack4RE)) {
                        outLine(3, "%s.setPositiveRE(\"%s\");", sreNames.peek(), content);
                    } else
                        outLine(3, "%s.setNegativeRE(\"%s\");", sreNames.peek(), content);

                    if (PoCoUtils.isMapSreFlag(flagStack4Exc))
                        outLine(3, "%s.setMatchSre(%s);", executionNames.peek(), sreNames.peek());

                    //if it is Bopsre case, we will need postpone setSRE till pop to the right Sre
                    if (PoCoUtils.isExchRHSSre(flagStack4Exc) && !PoCoUtils.isSREBopCase(flagStack4Sre))
                        outLine(3, "%s.setSRE(%s);", currentExchange, sreNames.peek());
                } else if (PoCoUtils.isIREMatch(flagStack4RE)) {
                    handleRE4IREcase(content);
                } else if (PoCoUtils.isExchMatch(flagStack4Exc)) {
                    //if content is variable then do nothing, otherwise make sure get
                    //the valid method signature for matching string
                    if (!PoCoUtils.isVariable(content))
                        //content = PoCoUtils.getMethodSignature(content);
                        outLine(3, "%s.setMatchString(\"%s\");", currentMatch, content);
                }
            }
        }
        return null;
    }

    private void handleRE4IREcase(String content) {
        if (isMethod(content))
            content = handleTransCase(content, policyName);

        if (PoCoUtils.isIREAction(flagStack4RE)) {
            outLine(3, "%s.setMatchString(\"%s\");", currentMatch, content);
        } else if (PoCoUtils.isIREResult(flagStack4RE)) {
            outLine(3, "%s.setMatchString(\"%s\");", currentMatch, content);
        } else //if (PoCoUtils.isIREResMatch(flagStack4RE)) {
            outLine(3, "%s.setResultMatchStr(\"%s\");", currentMatch, content);
    }

    private String reIsFuncCase(@NotNull PoCoParser.ReContext ctx) {
        String funName = ctx.function().fxnname().getText().trim();
        String argStr = "";
        if (ctx.function().INIT() != null) {
            funName += "new";
        }

        if (ctx.function().arglist() != null && ctx.function().arglist().getText().trim().length() != 0) {
            resetArgStr();
            flagStack4Arg.push(ParsFlgConsts.parsArgs);
            visitChildren(ctx.function().arglist());
            flagStack4Arg.pop();
            argStr = PoCoUtils.trimEndPunc(argListStr.toString(), ",");
        }

        return funName + "(" + argStr + ")";
    }

    private String reIsObjCase(@NotNull PoCoParser.ReContext ctx, String content) {
        if (PoCoUtils.isParsingArg(flagStack4Arg)) {
            argListStr.append(ctx.object().getText() + ",");
        } else {
            try {
                content = parseObject(ctx.object().qid().getText(), ctx.object().re().getText());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return content;
    }

    private String dollarReNotArgCase(@NotNull PoCoParser.ReContext ctx) {
        String content = "";
        String[] objInfos = PoCoUtils.objMethodCall(ctx.qid().getText());
        if (objInfos != null) {
            content = ctx.getText();
        } else if (closure != null && closure.isVarsContain(policyName + "_" + ctx.getText().substring(1))) {
            content = ctx.getText();
        } else {
            content = loadFromFunction(policyName + "_" + ctx.qid().getText().trim());
            if(content == null)
                content = "$"+policyName + "_" + ctx.qid().getText().trim();
        }



        if (ctx.opparamlist() != null && ctx.opparamlist().getText().trim().length() != 0) {
            //switch the var with content
            ArrayList<String> arglist = getFunArgList(policyName + "_" + ctx.qid().getText());
            if (arglist == null) {
                System.err.println("THe argument(s) specified for the function: " +
                        policyName + "_" + ctx.qid().getText() + " are in correct");
                System.exit(-1);
            }
            int index = 0;
            resetArgStr();
            flagStack4Arg.push(ParsFlgConsts.parsArgs);
            visitChildren(ctx.opparamlist());
            flagStack4Arg.pop();
            String[] newArgs = PoCoUtils.trimEndPunc(argListStr.toString(), ",").split(",");
            for (int i = 0; i < newArgs.length; i++)
                content = content.replace("$" + arglist.get(0), newArgs[i]);

        } else {
            content = PoCoUtils.attachPolicyName(policyName + "_", content);
        }
        //System.out.println("conent: " + content + "\n");
        return content;
    }

    private void dollarReAsArgCase(String varname) {
        String temp = policyName + "_" + varname;
        //first check if the argument is variable or not, if so only add the
        //variable name since its type may change
        if (closure != null && closure.isVarsContain(temp))
            argListStr.append("$" + temp + ",");
        else //then check the function closure
            argListStr.append(closure.loadFrmFunctions(temp).getVarContext().trim() + ",");

    }

    private void handleReAtCase(@NotNull PoCoParser.ReContext ctx) {
        if (ctx.id() != null && closure == null)
            throw new NullPointerException("No such var exist.");

        if (PoCoUtils.isParsingArg(flagStack4Arg)) {
            dollarReAsArgCase(ctx.id().getText());

            if (ctx.re(0).rewild() != null) {
                if (PoCoUtils.isIREAction(flagStack4RE) || PoCoUtils.isIREResMatch(flagStack4RE)) {
                    System.out.println("currentMatch: " + currentMatch);
                    outLine(3, "%s.setWildcard(true);", currentMatch);
                }
            }
        } else {
            visitRe(ctx.re(0));
        }
    }

    private void handleReBopCase(@NotNull PoCoParser.ReContext ctx) {
        flagStack4RE.push(ParsFlgConsts.isReBop);
        visitChildren(ctx);
        flagStack4RE.pop();

        //if not the case that is rebop is inside another rebop, then we will
        //set the parsed value to proper attribute,
        if (flagStack4RE.empty() || !PoCoUtils.isReBopFlag(flagStack4RE)) {
            String temp = PoCoUtils.trimEndPunc(reBopStr.toString(), "|");
            if (isMethod(temp))
                temp = handleTransCase(temp,policyName);
            resetREBopStr();
            if (PoCoUtils.isPosNegRe4SRE(flagStack4RE)) {
                if (PoCoUtils.isSrePosRE(flagStack4RE))
                    outLine(3, "%s.setPositiveRE(\"%s\");", sreNames.peek(), temp);
                else
                    outLine(3, "%s.setNegativeRE(\"%s\");", sreNames.peek(), temp);

                if (PoCoUtils.isMapSreFlag(flagStack4Exc))
                    outLine(3, "%s.setMatchSre(%s);", executionNames.peek(), sreNames.peek());

                //if it is Bopsre case, we will need postpone setSRE till pop to the right Sre
                if (PoCoUtils.isExchRHSSre(flagStack4Exc) && !PoCoUtils.isSREBopCase(flagStack4Sre))
                    outLine(3, "%s.setSRE(%s);", currentExchange, sreNames.peek());
            } else if (PoCoUtils.isIREMatch(flagStack4RE)) {
                if (PoCoUtils.isIREAction(flagStack4RE)) {
                    //temp = PoCoUtils.getMethodSignature(temp);
                    outLine(3, "%s.setMatchString(\"%s\");", currentMatch, temp);
                } else if (PoCoUtils.isIREResult(flagStack4RE)) {
                    outLine(3, "%s.setMatchString(\"%s\");", currentMatch, temp);
                } else {
                    outLine(3, "%s.setResultMatchStr(\"%s\");", currentMatch, temp);
                }
            } else if (PoCoUtils.isExchMatch(flagStack4Exc)) {
                //temp = PoCoUtils.getMethodSignature(temp);
                outLine(3, "%s.setMatchString(\"%s\");", currentMatch, temp);
            }
        }

    }

    private void resetREBopStr() {
        reBopStr = new StringBuilder();
    }

    private void handleREonRHS(@NotNull PoCoParser.ReContext ctx) {
        if (PoCoUtils.isParsingArg(flagStack4Arg)) {
            String matchStr = null;
            if (ctx.qid() != null) {
                String varName = policyName + "_" + ctx.qid().getText();
                String temp = loadFromFunction(varName);
                //not function but var case
                if(temp ==null)
                    temp = "$"+varName;
                argListStr.append(temp + ",");
            } else if (ctx.object() != null) {
                argListStr.append(ctx.object().getText() + ",");
            } else if (ctx.rewild() != null) {
                argListStr.append("*,");
            } else {
                argListStr.append(ctx.getText() + ",");
            }
        } else {
            if (ctx.rebop() != null && !ctx.re(1).getText().toString().equals("()")) {
                flagStack4RE.push(ParsFlgConsts.isReBop);
                String matchsName = "matchs" + matchsNum++;
                outLine(3, "Matchs %s = new Matchs(\"||\");", matchsName);
                matchNames.push(matchsName);
                visitChildren(ctx);
                matchNames.pop();
                outLine(3, "%s.addMatcher(%s);", currentExchange, matchsName);
                flagStack4RE.pop();
            } else {
                String matchStr = null;
                if (ctx.qid() != null) {
                    // if it is a variable, that means we need dynamically check its value at runtime,
                    //there for we will only store the variable name here
                    if (closure != null && closure.isVarsContain(policyName + "_" + ctx.qid().getText())) {
                        matchStr = "$" + policyName + "_" + ctx.qid().getText();
                    } else {
                        matchStr = loadFromFunction(policyName + "_" + ctx.qid().getText());
                    }
                } else if (ctx.function() != null) {
                    //first handle function name
                    matchStr = ctx.function().fxnname().getText();
                    if (ctx.function().INIT() != null)
                        matchStr = matchStr.substring(0, matchStr.length() - 1) + "new";

                    //first handle function parameters
                    if (ctx.function().arglist() != null
                            && ctx.function().arglist().getText().trim().length() > 0) {
                        flagStack4Arg.push(ParsFlgConsts.parsArgs);
                        resetArgStr();
                        visitChildren(ctx.function());
                        flagStack4Arg.pop();
                        matchStr += "(" + PoCoUtils.trimEndPunc(argListStr.toString(), ",") + ")";
                    }
                } else {
                    matchStr = ctx.getText();
                }

                if (!PoCoUtils.isReBopFlag(flagStack4RE)) {
                    String matchName = "match" + matchNum++;
                    outLine(3, "Match %s = new Match(\"%s\");", matchName, PoCoUtils.validateStr(matchStr.trim()));
                    outLine(3, "%s.addMatcher(%s);", currentExchange, matchName);
                } else {
                    String matchName = "match" + matchNum++;
                    outLine(3, "Match %s = new Match(\"%s\");", matchName, PoCoUtils.validateStr(matchStr.trim()));
                    outLine(3, "%s.addChild(%s);", matchNames.peek(), matchName);
                }
            }
        }
    }

    /**
     * use to get the last seen modifier and reset the flags of the modifiers to false
     */
    public String getModifierFlag(PoCoParser.ExecutionContext ctx) {
        String result = "none";
        if (ctx.getParent() != null) {
            if (ctx.getParent().getRuleIndex() == 20) {//RULE_execution
                int size = ctx.getParent().getChildCount();
                if (ctx.getParent().getChild(size - 1).getText().equals("*")) {
                    result = "*";
                } else if (ctx.getParent().getChild(size - 1).getText().equals("+")) {
                    result = "+";
                } else if (ctx.getParent().getChild(size - 1).equals(ctx)) {
                    if (ctx.getParent().getParent().getRuleIndex() == 20) {
                        size = ctx.getParent().getParent().getChildCount();
                        if (ctx.getParent().getParent().getChild(size - 1).getText().equals("*"))
                            result = "*";
                        else if (ctx.getParent().getParent().getChild(size - 1).getText().equals("+"))
                            result = "+";
                    }
                }
            }
        }
        return result;
    }

    public String getModifierFlag() {
        String result = "none";
        if (PoCoUtils.hasAsterisk(flagStack4Exc)) {
            result = "*";
            flagStack4Exc.pop();
        } else if (PoCoUtils.hasPlus(flagStack4Exc)) {
            result = "+";
            flagStack4Exc.pop();
        } else if (PoCoUtils.hasNone(flagStack4Exc)) {
            result = "none";
            flagStack4Exc.pop();
        }
        return result;
    }

    /**
     * use to set the modifier flag
     *
     * @param asterisk if the execution has asterisk
     * @param plus     if the execution has plus
     */
    public void setModifierFlag(boolean asterisk, boolean plus) {
        if (asterisk)
            flagStack4Exc.push(ParsFlgConsts.hasAsterisk);
        else if (plus)
            flagStack4Exc.push(ParsFlgConsts.hasPlus);
        else
            flagStack4Exc.push(ParsFlgConsts.hasNone);
    }

    public void setSREvalue(String fieldName, String sreName) {
        if (fieldName.contains("uopSRE"))
            outLine(3, "%s.setSRE(%s);", fieldName, sreName);
        else if (fieldName.contains("bopSRE")) {
            if (PoCoUtils.isSREBop1(flagStack4Sre))
                outLine(3, "%s.setSre1(%s);", fieldName, sreName);
            else {//if (PoCoUtils.isSREBop2(flagStack4Sre))
                outLine(3, "%s.setSre2(%s);", fieldName, sreName);
            }
        }
    }

    /**
     * This method use to track the value from object format
     */
    private String parseObject(String type, String value) throws Exception {
        switch (type) {
            case "Integer":
                String objType = PoCoUtils.getObjType(value);
                if (objType != null) {
                    Field field = Class.forName(objType).getField(PoCoUtils.getObjVal(value));
                    return new Integer(field.getInt(null)).toString();
                } else
                    return value;
                //will add more case here
            default:
                return value;
        }
    }

    private String loadFromFunction(String varName) {
        String returnStr = null;
        if (closure != null && closure.loadFrmFunctions(varName) != null)
            returnStr = closure.loadFrmFunctions(varName).getVarContext().trim();

        return returnStr;
    }

    private ArrayList<String> getFunArgList(String varName) {
        ArrayList<String> returnStr = null;
        if (closure != null && closure.loadFrmFunctions(varName) != null)
            returnStr = closure.loadFrmFunctions(varName).getFunArgs();

        return returnStr;
    }

    public String getArgStr4PosSRE(String varName) {
        if (closure.isFunctionsContain(varName) && closure.loadFrmFunctions(varName).getVarContext() != null) {
            String varVal = closure.loadFrmFunctions(varName).getVarContext();
            String varTyp = "java.lang.String";
            if (closure.loadFrmFunctions(varName).getVarType() != null)
                varTyp = closure.loadFrmFunctions(varName).getVarType();
            varName = varVal; //"#" + varTyp + "{"+varVal+"}";
        } else if (closure.isVarsContain(varName) && closure.loadFrmVars(varName).getVarType() != null) {
            String varTyp = "java.lang.String";
            if (closure.loadFrmVars(varName).getVarType() != null)
                varTyp = closure.loadFrmVars(varName).getVarType();
            varName = "#" + varTyp + "{$" + varName + "}";
        } else
            varName = "$" + varName;

        return varName;
    }

    private void resetArgStr() {
        argListStr = new StringBuilder();
    }

    public static boolean isMethod(String str) {
        if (str == null)
            return false;
        return isMatching("^(.+)\\((.*)\\)$", str);
    }

    public static boolean isPoCoObject(String str) {
        if (str == null)
            return false;
        return (!isMethod(str)) && isMatching("#(.+)\\{(.+)\\}", str);
    }

    private static boolean isMatching(String reg, String str4Match) {
        Pattern pattern = Pattern.compile(reg);
        Matcher matcher = pattern.matcher(str4Match);
        return matcher.find();
    }

    private static String handleTransCase(String content, String policyName) {
        if(PoCoUtils.isMethod(content)) {
            String mtdName = PoCoUtils.getMtdName(content);
            if(mtdName.startsWith("abs_"))
                ;
            else if (!mtdName.startsWith("$") && !mtdName.contains(".")) {
                content = content.replace(mtdName, "com.poco." + policyName + "_Trans." + mtdName);
            }
        }
        return content;
    }

    /**
     * Generates code for class representing a Main tree policy.
     *
     * @param ctx
     * @return
     */
    /*@Override
    public Void visitMetapol(@NotNull PoCoParser.MetapolContext ctx) {

        outLine(0, "class MainPolicy extends Policy {");
        outLine(1, "private Stack<String> monitoringEvents;");
        outLine(1, "private ArrayList<Policy> children;");
        outLine(1, "public MainPolicy() {");
        outLine(2, "children = new ArrayList<Policy>();");
        //iterate through policies and add to list
        AddPolicies(ctx.treedefs());
        outLine(2, "this.monitoringEvents = new Stack<>();");
        outLine(1, "}");

        outLine(1,  "public void queryAction(Event event) {");
        outLine(2,  "ArrayList<SRE> results = ne

        return null;
    }

}
    /**
     * Generates code for class representing a Main tree policy.
     *
     * @param ctx
     * @return
     */
    /*@Override
    public Void visitMetapol(@NotNull PoCoParser.MetapolContext ctx) {

        outLine(0, "class MainPolicy extends Policy {");
        outLine(1, "private Stack<String> monitoringEvents;");
        outLine(1, "private ArrayList<Policy> children;");
        outLine(1, "public MainPolicy() {");
        outLine(2, "children = new ArrayList<Policy>();");
        //iterate through policies and add to list
        AddPolicies(ctx.treedefs());
        outLine(2, "this.monitoringEvents = new Stack<>();");
        outLine(1, "}");

        outLine(1,  "public void queryAction(Event event) {");
        outLine(2,  "ArrayList<SRE> results = new ArrayList<SRE>");
        //iterate through policies and query all
        AddQueries(ctx);
        outLine(2,  "monitoringEvents.push(event.getSignature());");
        outLine(2,  "//when accept is false, the returned SRE value is NULL");
        //TODO: not looping through all children yet
        outLine(2,  "if (results.get(0) == null) {");
        outLine(3,  "monitoringEvents.pop();");
        outLine(3,  "System.exit(-1);");
        outLine(2,  "}");
        outLine(2,  "boolean posMatch = false;");
        outLine(2,  "boolean negMatch = false;");
        outLine(2,  "if (result.get(0).positiveRE().length() > 0) {");
        outLine(3,  "boolean promoted = false;");
        outLine(3,  "//if the monitoringEvent is Result, it should be popped on the stack,");
        outLine(3,  "//since we already get the result");
        outLine(3,  "if(!monitoringEvents.empty())");
        outLine(4,  "if(event.eventType!= null && event.eventType.equals(\"Result\"))");
        outLine(5,  "monitoringEvents.pop();");
        outLine(4,  "if(monitoringEvents.peek().contains(result.get(0).positiveRE().toString())) {");
        outLine(5,  "promoted = true;");
        outLine(4,  "}");
        outLine(4,  "if (promoted) {");
        outLine(5,  "System.out.println(\"the action is allowed\");");
        outLine(5,  "monitoringEvents.pop();");
        outLine(4,  "} else {");
        outLine(5,  "try {");
        outLine(6,  "Promoter.Reflect(result.get(0).positiveRE());");
        outLine(5,  "} catch (Exception ex) {");
        outLine(6,  "ex.printStackTrace();");
        outLine(5,  "}");
        outLine(4,  "}");
        outLine(3,  "}");
        outLine(3,  "if (result.get(0).negativeRE().length() > 0) {");
        outLine(4,  "// if already on stack, show System.exit(-1);");
        outLine(4,  "Pattern negPat = Pattern.compile(result.get(0).negativeRE());");
        outLine(4,  "Matcher negMatcher = negPat.matcher(event.getSignature());");
        outLine(4,  "negMatch = negMatcher.find();");
        outLine(3,  "}");
        outLine(3,  "if (posMatch) {");
        outLine(4,  "return;");
        outLine(3,  "}");
        outLine(3,  "if (negMatch) {");
        outLine(4,  "System.exit(-1);");
        outLine(3,  "}");
        outLine(2,  "}");
        outLine(1,  "}");
        outLine(0, "}");

        return null;
    }

    private void AddPolicies(PoCoParser.TreedefsContext ctx)
    {
        PoCoParser.TreedefContext treedef = ctx.treedef();
        AddTreePolicies(treedef);
        PoCoParser.TreedefsContext treedefs = ctx.treedefs();
        if(treedefs != null)
        {
            AddPolicies(treedefs);
        }
    }

    private void AddTreePolicies(PoCoParser.TreedefContext ctx)
    {
        if(ctx.id().size() > 1)
        {
            String policyName = ctx.id(1).getText();
            outLine(2,  "children.add(new %s());", policyName);
        }
        PoCoParser.PolicyargsContext policyargs = ctx.policyargs();
        if(policyargs != null)
        {
            AddPolicyArgsPolicies(policyargs);
        }
    }

    private void AddPolicyArgsPolicies(PoCoParser.PolicyargsContext ctx)
    {
        PoCoParser.PolicyargContext policyarg = ctx.policyarg();
        AddPolicyArgPolicies(policyarg);
        if(ctx.policyargs() != null)
        {
            AddPolicyArgsPolicies(ctx.policyargs());
        }
    }

    private void AddPolicyArgPolicies(PoCoParser.PolicyargContext ctx)
    {
        if(ctx != null) {
            if (ctx.AT() == null) {
                String policyName = ctx.id().getText();
                outLine(2, "children.add(new %s());", policyName);
                AddPolicyArgsPolicies(ctx.policyargs());
            }
            else
            {
                AddPolicyArgPolicies(ctx.policyarg());
            }
        }
    }

    private void AddQueries(PoCoParser.MetapolContext ctx) {
        outLine(2,  "for (i=0; i < children.size(); i++) {");
        outLine(3,  "results.add(children.get(i).query(event));");
        outLine(2,  "}");
    }*/
}