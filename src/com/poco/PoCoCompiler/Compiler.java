package com.poco.PoCoCompiler;

import com.poco.Extractor.*;
import com.poco.PoCoParser.PoCoLexer;
import com.poco.PoCoParser.PoCoParser;
import com.poco.StaticAnalysis.StaticAnalysis;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import joptsimple.OptionSpec;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Compiler {
    /*
     * COMPILATION OPTIONS
     */
    /** Output verbose information to console */
    private final boolean verboseFlag;
    /** Quit compilation after a certain phase */
    private final String endAfterFlag;

    /*
     * FILES AND FOLDERS
     */
    /** Folder for compiler output */
    private Path outputDir;
    /** Path to main PoCo policy */
    private Path policyFilePath;
    /** Paths to files (jar or class) to be instrumented */
    private Path[] scanFilePaths;
    /** Used to write to the AspectJ file */
    private PrintWriter aspectWriter = null;
    /** Other policies that need to be parsed (found via "import" statements) */
    private LinkedHashSet<String> additionalPolicies = new LinkedHashSet<>();
    /*
     * COMPILATION RESULTS
     */
    /** Name of PoCo policy (e.g. CorysPolicy.poco is "CorysPolicy") */
    private String policyName;
    /** Parse tree generated by the ANTLR grammar */
    private ParseTree parseTree = null;
    /** Regular expressions from PoCo policy */
    private ArrayList<String> extractedREs = null;
    
    /** * pointcut info  from PoCo policy */
    ArrayList<String> extractedPCs = new ArrayList<String>();
    Hashtable<String, HashSet<String>> extractedPtCuts = null;
    //add this in order to generate the different kinds of advices for pointcuts
    Hashtable<String, HashSet<String>> extractedPtCuts4Promoter = null;
    Hashtable<String, HashSet<String>> extractedPtCuts4Results = null;

    /**  All method signatures from files in scanFilePaths */
    private LinkedHashSet<String> extractedMethodSignatures = null;
    /**  * Each RE from the PoCo policy mapped to all matching methods  */
    private LinkedHashMap<String, ArrayList<String>> regexMethodMappings = null;
    private LinkedHashMap<String, ArrayList<String>> pointcutMappings = null;
    /**
     * vars and marcos value will be saved in closure
     */
    private Closure closure;
    private Hashtable<String, String> monitoredPC = new Hashtable<String, String>();
    private HashSet<String> varNeedBind;
    private HashSet<String> objParams;
    int pointcutNum = 0;
    /**
     * Writes a Collection object to a file, separated by newlines.
     * @param items object adhering to the Collection interface
     * @param savePath Path pointing to the save file location
     */
    public static void writeToFile(Collection<String> items, Path savePath) {
        try (FileWriter writeStream = new FileWriter(savePath.toFile())) {
            for (String item : items) {
                writeStream.write(item);
                writeStream.write('\n');
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }

    public void addPolicy(String newPolicy) {
        additionalPolicies.add(newPolicy);
    }

    private void jOut(int indentLevel, String text, Object... args) {
        // Indent to appropriate level
        int numSpaces = indentLevel * 4;
        for (int i = 0; i < numSpaces; i++) {
            aspectWriter.format(" ");
        }

        // Output supplied format string and append newline
        aspectWriter.format(text, args);
        aspectWriter.format("\n");
    }

    /**
     * Writes a hash map to a file. Each item is separated by a newline. Keys are left-justified and their
     * values are indented 4 spaces.
     * @param map LinkedHashMap to write to file (it's much faster to iterate over LinkedHashMaps)
     * @param savePath Path pointing to the save file location
     */
    public static void writeMapToFile(LinkedHashMap<String, ArrayList<String>> map, Path savePath) {
        try (FileWriter writeStream = new FileWriter(savePath.toFile())) {
            for (String key : map.keySet()) {
                writeStream.write(key + ":\n");
                for (String value : map.get(key)) {
                    writeStream.write("    ");
                    writeStream.write(value);
                    writeStream.write('\n');
                }
                writeStream.write('\n');
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
    }

    /**
     * Outputs log information to console if the verbose flag has been set (-v command line option).
     * @param format printf-style format string
     * @param args arguments to printf
     */
    private void vOut(String format, Object... args) {
        if (verboseFlag) {
            System.out.printf(format, args);
        }
    }

    /**
     * Constructor. Parses command-line arguments and outputs execution information.
     * @param arguments command-line arguments
     */
    public Compiler(String[] arguments) {
        // Set up command-line option parser (see JOpts library documentation for more information)
        OptionParser optParser = new OptionParser();
        optParser.accepts("extract");
        OptionSpec<String> outputOpt = optParser.accepts("o").withRequiredArg().ofType( String.class ).defaultsTo(Paths.get("").toAbsolutePath().toString());
        OptionSpec<String> scanOpts = optParser.accepts("c").withRequiredArg().ofType( String.class );
        OptionSpec<String> policyArgs = optParser.nonOptions().ofType( String.class );
        optParser.accepts("v");
        OptionSet options = optParser.parse(arguments);

        // User wants verbose output?
        this.verboseFlag = options.has("v");

        // Configure output directory
        this.outputDir = Paths.get(outputOpt.value(options));

        // Get name for PoCo Policy
        if (policyArgs.value(options) == null) {
            System.out.println("ERROR: Please provide at least one PoCo policy file.");
            System.exit(-1);
        }

        // Set up path to policy file and get name
        this.policyFilePath = Paths.get(policyArgs.value(options));
        String policyFileName = policyFilePath .getFileName().toString();
        this.policyName = policyFileName.substring(0, policyFileName.indexOf('.'));

        // Set up list of files to instrument/scan
        this.scanFilePaths = new Path[scanOpts.values(options).size()];
        for (int i = 0; i < scanOpts.values(options).size(); i++) {
            scanFilePaths[i] = Paths.get(scanOpts.values(options).get(i));
        }

        // "--extract" option indicates that the user only wants to extract REs
        if (options.has("extract")) {
            this.endAfterFlag = "extract";
        } else {
            this.endAfterFlag = "";
        }

        // Output execution information
        vOut("PoCo Compiler starting up with the following options:\n");
        if (endAfterFlag.length() > 0) {
            vOut("%s\n  %s\n", "End After:", endAfterFlag);
        }
        vOut("%s\n  %s\n", "PoCo Policy:", policyFilePath.toString());
        vOut("%s\n  %s\n", "Output Dir:", outputDir.toString());
        vOut("%s\n", "Scan Targets:");
        for (Path scanFilePath : scanFilePaths) {
            vOut("  %s\n", scanFilePath.toString());
        }
        if (scanFilePaths.length == 0) {
            vOut("  %s\n", "(None)");
        }
        vOut("\n");
    }

    /**
     * Public-facing method to execute the compilation phases in the correct order.
     */
    public void compile() {
        // Runs through the steps of compilation (parse, extract, mapping)
        this.doParse();
        this.doGenerateClosure();
        this.doExtract();
        this.doStaticAnalysis();

        // User wants to only do extracts
        if (endAfterFlag.equals("extract")) {
            return;
        }

        //this.doMapping();
        this.doGenerateAspectJ();
    }

    /**
     * Parses the supplied PoCo Policy file, if it exists. Otherwise exits with error.
     *
     * Step #1 in compilation process as the parse tree is required by other phases.
     */
    private void doParse() {
        // Parse the specified PoCo policy
        vOut("Parsing PoCo Policy...\n");
        ANTLRInputStream antlrStream = null;

        // Open the PoCo policy file
        try {
            antlrStream = new ANTLRInputStream(new FileInputStream(policyFilePath.toFile()));
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
            System.exit(-1);
        }

        // Call lexer, get tokens, pass tokens to parser. Obtain the parseTree for the root-level rule, "policy".
        PoCoLexer lexer = new PoCoLexer(antlrStream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        PoCoParser parser = new PoCoParser(tokens);
        this.parseTree = parser.policy();
    }

/**
     * Extracts vars and macros that defined before executions,
     * so that the Extractor will be able to get info for generating pointcut
    */
    private void doGenerateClosure() {
        ExtractClosure extractClosure = new ExtractClosure(this.closure);
        extractClosure.visit(parseTree);
        closure =  extractClosure.getClosure();
    }

    /**
     * Extracts the REs from the PoCo policy for use by the mapping functions. Also extracts all method signatures from
     * all to-be-instrumented files.
     *
     * Step #2 in compilation process. Requires doParse() to have been called prior.
     */
    private void doExtract() {
        // Extract REs from PoCo Policy for mapping
        vOut("Extracting REs from policy...\n");
        Extractor regexExtractor = new Extractor();
        regexExtractor.visit(parseTree);
        this.extractedREs = regexExtractor.getMatchStrings();
        PointCutExtractor pcExtractor = new PointCutExtractor(this.closure);
        pcExtractor.visit(parseTree);
        this.extractedPtCuts = pcExtractor.getPCStrings();
        this.extractedPtCuts4Promoter = pcExtractor.getPCStrs4Promoter();
        this.extractedPtCuts4Results = pcExtractor.getPCStrs4Result();
        this.objParams = pcExtractor.getObjParams();
        /*Set<String> set = this.extractedPtCuts.keySet();
        for (String entry : set)
            extractedPCs.add(entry);
        set = this.extractedPtCuts4Promoter.keySet();
        for (String entry : set)
            extractedPCs.add(entry);

        // Write REs to a file
        //Path policyExtractPath = outputDir.resolve(policyName + "_extracts.txt");
        //writeToFile(extractedREs, policyExtractPath);
        //writeToFile(extractedPCs, policyExtractPath);
        // Extract all method signatures from jar/class files
        //vOut("Extracting method signatures from scan files...\n");*/
        this.extractedMethodSignatures = new LinkedHashSet<>();

        //Modify temporarily
        /*for (Path scanFilePath : scanFilePaths) {
            this.extractedMethodSignatures.addAll(new MethodSignaturesExtract(scanFilePath).getMethodSignatures());
        }*/
        // Write the extracted methods to a file
        Path methodExtractPath = outputDir.resolve(policyName + "_allmethods.txt");
        writeToFile(extractedMethodSignatures, methodExtractPath);
    }

    /**
     * Runs static analysis on policy. doExtract() must have already been called
     */
    private void doStaticAnalysis() {
        vOut("Performing static analysis...\n");
        ANTLRInputStream antlrStream = null;

        try {
            antlrStream = new ANTLRInputStream(new FileInputStream(policyFilePath.toFile()));
            StaticAnalysis sa = new StaticAnalysis();
            sa.StaticAnalysis(antlrStream, this.extractedMethodSignatures);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
            System.exit(-1);
        }
    }

    /**
     * Maps the REs from the PoCo policy to the extracted method signatures.
     * <p/>
     * Step #3 in the compilation process. doParse() and doExtract() should be called prior.
     */
    private void doMapping() {
        // Generate mappings from extracted REs -> method signatures
        vOut("Mapping REs from policy to method signatures...\n");
        //RegexMapper mapper = new RegexMapper(extractedREs, extractedMethodSignatures);
        RegexMapper mapper = new RegexMapper(extractedPCs, extractedMethodSignatures);
        mapper.mapRegexes();
        this.regexMethodMappings = mapper.getMappings();

        // Write mappings to a text file
        Path mappingExtractPath = outputDir.resolve(policyName + "_mappings.txt");
        writeMapToFile(regexMethodMappings, mappingExtractPath);
    }

    /**
     * Step #4 in the compilation process.
     */
    private void doGenerateAspectJ() {
        // Generate AspectJ pointcuts according to the mappings
        Path poincutPath = outputDir.resolve("Aspect" + policyName + ".aj");
        String aspectName = "Aspect" + policyName;
        vOut("Generating AspectJ file %s ...\n", poincutPath.getFileName());

        // Open up the AspectJ file for writing
        try {
            aspectWriter = new PrintWriter(poincutPath.toFile());
        } catch (Exception ex) {
            System.out.println("ERROR during pointcut gen");
            System.out.println(ex.getMessage());
            System.exit(-1);
        }
        // Create some class names
        String childPolicyName = policyName;
        outAspectPrologue(aspectName, childPolicyName);

        //adding variable declares so later we can updated the dynamic binding values.
        if (closure != null)
            genVarClosure(aspectName);
        jOut(1, "");
        //add this paragraph for generate pointcut for reflection calls
        //only reflection calls can be made is thru PoCo
        jOut(1, "pointcut PC4Reflection():");
        jOut(2, "call (* Method.invoke(Object, Object...)) && !within(com.poco.Promoter);\n");
        jOut(1, "Object around(): PC4Reflection()   { ");
        jOut(2, "return new SRE(null,\".\"); ");
        jOut(1, "}\n");

        genAdvice(extractedPtCuts, 0);
        genAdvice(extractedPtCuts4Results,1); //only result need gen after advice

        if (this.extractedPtCuts4Promoter.size() > 0) {
            jOut(1, "pointcut PointCut%d(Method run):", pointcutNum);
            jOut(2, "target(run) &&call(Object Method.invoke(..));\n");
            outAdvicePrologue4Result("PointCut" + pointcutNum);
            pointcutNum++;
            addStackMatchingFunction();
        }
        // Generate policy classes
        PolicyVisitor pvisitor = new PolicyVisitor(aspectWriter, 1, this.closure);
        pvisitor.visit(parseTree);

        if (pvisitor.hasTransation()) {
            createTransUtil(pvisitor.getTransactions());
        }

        outAspectEpilogue();

        aspectWriter.close();
        aspectWriter = null;
    }

    private void genAdvice(Hashtable<String, HashSet<String>> pointcuts, int mode) {
        Set<String> keys = pointcuts.keySet();
        for (Iterator<String> key = keys.iterator(); key.hasNext(); ) {
            int thisNodeMode = mode;
            String entry = key.next();

            if (mode == 0 && extractedPtCuts4Results.containsKey(entry)) {
                extractedPtCuts4Results.remove(entry);
                thisNodeMode = 2;
            }
            varNeedBind = pointcuts.get(entry);

            //argTypeList:  Integer, String
            String argList4PC = "";
            //argList4PC :  Integer value0, String value1
            String argList4Call = "";
            //this one will use for generate monitor values for defining the around advice
            //the different btw this and monitorVals is that, in advice, * should be deleted.
            //e.g., pointcut PointCut1(String value0):call(java.io.File.new(..,String)) && args(*,value0);
            //      Object around(String value0): PointCut1(value0) {.....}
            String argLs4Around = "";
            //argList4Call: value0, value1
            String argTypeList = "";
            //aspect will only monitor the values that matches
            String monitorVals = "";

            String callStr = getPCMethodName(entry);
            if (callStr.substring(0, 2).equals("$$")) {
                if (closure.getContext(callStr.substring(2, callStr.length() - 2)) != null) {
                    callStr = closure.getContext(callStr.substring(2, callStr.length() - 2));
                }
            }
            //capture return type of the monitoring method t
            //if the method signature included the return type(if user included the return
            // type then has to have space btw return type and method name) then just use it,
            //if not, we will consider any none constructor method(.new) with * return type
            String funReturnType = getPCMethodName(callStr).split(" ")[0];
            String funName = getPCMethodName(callStr);
            if (funName.split(" ").length == 1 && !funName.substring(funName.length() - 4, funName.length()).equals(".new")) {
                funName = "* " + funName;
            }
            //get the var name that need 2B dynamically updated
            String[] argsList = getArgsLstArray(entry);
            if (argsList != null) {
                int count = 0;
                for (int i = 0; i < argsList.length; i++) {
                    String str = getArgsType(argsList[i], 1);
                    if (!str.equals("..")) {
                        String varTyp = getArgsType(argsList[i], 1);
                        argTypeList += varTyp;
                        argList4PC += varTyp + " value" + count;
                        if (getArgsType(argsList[i], 2) != null) {
                            monitorVals += argList4PC + getArgsType(argsList[i], 2);
                            if (i != argsList.length - 1)
                                monitorVals += ",";
                        }
                        argLs4Around += "value" + count;
                        argList4Call += "value" + count++;
                        if (i != argsList.length - 1) {
                            argTypeList += ",";
                            argList4PC += ",";
                            argList4Call += ",";
                            argLs4Around += ",";
                        }
                    } else {
                        argTypeList  += "..";
                        argList4Call += "*";
                        if (i != argsList.length - 1)
                            argList4Call += ",";
                    }
                }
                argTypeList = trimLastPunctuation(argTypeList, ",");
                argList4PC = trimLastPunctuation(argList4PC, ",");
                argList4Call = trimLastPunctuation(argList4Call, ",");
                argLs4Around = trimLastPunctuation(argLs4Around, ",");
                monitorVals = trimLastPunctuation(monitorVals, ",");
            }
            //if no values need to be monitored then no need for define argument for pointcut
            if (monitorVals != null && monitorVals.length() > 0) {
                jOut(1, "pointcut PointCut%d(%s):", pointcutNum, argList4PC);

                String args = "";
                if (entry.indexOf("(") != -1 && entry.indexOf(")") != -1) {
                    args = getArgsTyp4PC(entry.substring(entry.indexOf("("), entry.length()));
                }
                callStr = (funName + "(" + args + ")").replace("\\", "");
                if (argTypeList.trim().length() > 0) {
                    jOut(2, "call(%s) && args(%s);\n", callStr, argList4Call);
                } else {
                    jOut(2, "call(%s);\n", callStr);
                }

                outAdvicePrologue("PointCut" + pointcutNum, argList4PC, argLs4Around, monitorVals, funReturnType, thisNodeMode);
            } else {
                jOut(1, "pointcut PointCut%d():", pointcutNum);
                callStr = getPCMethodName(entry);
                System.out.println("argTypeList: " + argTypeList);
                jOut(2, "call(%s(%s));\n", callStr, argTypeList);
                outAdvicePrologue("PointCut" + pointcutNum, argList4PC, argLs4Around, monitorVals, funReturnType, thisNodeMode);
            }
            pointcutNum++;
        }
    }

    private void outAspectEpilogue() {
        jOut(0, "}");
    }

    private void addStackMatchingFunction() {
        jOut(1, "private boolean matchingStack(String runningMethod) {");
        jOut(2, "if (root.promotedEvents != null)");
        jOut(3, "if(root.promotedEvents.peek().equals(runningMethod)) {");
        jOut(4, "root.promotedEvents.pop();");
        jOut(4, "return true;");
        jOut(3, "}");
        jOut(2, "return false;");
        jOut(1, "}\n");
    }

    private String trimLastPunctuation(String str, String punctuation) {
        while (str.length() > 1) {
            int x = str.length() - punctuation.length();
            if (x > 0 && str.substring(x, str.length()).contains(punctuation))
                str = str.substring(0, x);
            else if (x == 0)
                return "";
            else
                break;
        }
        return str;
    }

    private void createTransUtil(String str) {
        String fileName = policyName + "_Utils";
        Path path = outputDir.resolve(fileName + ".java");

        StringBuffer stringBuffer = new StringBuffer();
        //write the package info
        ArrayList<String> packs = getUtilPackages(str);
        if (packs != null) {
            for (Iterator<String> it = packs.iterator(); it.hasNext(); ) {
                stringBuffer = stringBuffer.append(it.next());
                stringBuffer = stringBuffer.append(System.getProperty("line.separator"));
            }
            stringBuffer = stringBuffer.append(System.getProperty("line.separator"));
        }
        //write the class name
        stringBuffer = stringBuffer.append("public class " + fileName + "{");
        stringBuffer = stringBuffer.append(System.getProperty("line.separator"));
        //add methods
        ArrayList<String> methods = getUtilMethods(str);
        if (methods != null) {
            for (Iterator<String> it = methods.iterator(); it.hasNext(); ) {
                stringBuffer = stringBuffer.append(it.next());
                stringBuffer = stringBuffer.append(System.getProperty("line.separator"));
            }
        }
        stringBuffer = stringBuffer.append("}");
        //write into "policyName_Utils.java"
        try {
            FileWriter fw = new FileWriter(path.toString());
            fw.write(stringBuffer.toString());
            fw.flush();
            fw.close();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private ArrayList<String> getUtilPackages(String str) {
        ArrayList<String> packages = new ArrayList<>();
        String reg = "\\s*import\\s+(.+);";
        Pattern pattern = Pattern.compile(reg);
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            packages.add("import " + matcher.group(1).trim() + ";");
        }
        return packages;
    }

    private ArrayList<String> getUtilMethods(String str) {
        ArrayList<Integer> methodIndex = new ArrayList<>();
        ArrayList<String> methods = new ArrayList<>();
        String reg = "\\s*(public\\s+(static)?\\s+\\w+\\s+\\w+\\s*\\(.*?\\))\\s*";
        Pattern pattern = Pattern.compile(reg);
        Matcher matcher = pattern.matcher(str);
        while (matcher.find())
            methodIndex.add(matcher.start());

        if (methodIndex.size() > 0) {
            int firstIndex = methodIndex.get(0);
            methodIndex.remove(0);
            for (Iterator<Integer> it = methodIndex.iterator(); it.hasNext(); ) {
                int nextIndex = it.next();
                methods.add("\t" + str.substring(firstIndex, nextIndex).trim());
                firstIndex = nextIndex;
            }
            methods.add("\t" + str.substring(firstIndex, str.length()).trim());
        }

        return methods;
    }

    private void outAspectPrologue(String aspectName, String childName) {
        jOut(0, "import com.poco.PoCoRuntime.*;");
        jOut(0, "import java.lang.reflect.Method;\n");
        jOut(0, "public aspect %s {", aspectName);
        jOut(1, "private DummyRootPolicy root = new DummyRootPolicy( new %s() );\n", childName);
    }

    private void outAdvicePrologue(String pointcutName, String aroundlist, String arglist, String monitorVal, String funReturnType, int mode) {
         /* aroundlist: String value0,int value1; arglist: value0,value1; monitorVal String value0$$*.class$$*/
        if (monitorVal != null && monitorVal.length() > 0) {
            String[] typeValArray = monitorVal.split(",");
            String[] varTyps = new String[typeValArray.length];
            String[] varNams = new String[typeValArray.length];
            String[] varVals = new String[typeValArray.length];
            if (typeValArray != null) {
                String reg1 = "(.+)\\$\\$\\$(.+)\\$\\$\\$";
                String reg2 = "(.+)\\$\\$(.+)\\$\\$";
                Pattern pattern1 = Pattern.compile(reg1);
                Pattern pattern2 = Pattern.compile(reg2);
                Matcher matcher1;
                Matcher matcher2;
                for (int i = 0; i < typeValArray.length; i++) {
                    matcher1 = pattern1.matcher(typeValArray[i]);
                    matcher2 = pattern2.matcher(typeValArray[i]);
                    if (matcher1.find()) {
                        varTyps[i] = matcher1.group(1).toString().trim().split(" ")[0];
                        varNams[i] = matcher1.group(1).toString().trim().split(" ")[1];
                        varVals[i] = matcher1.group(2).toString().trim();
                    } else if (matcher2.find()) {
                        varTyps[i] = matcher2.group(1).toString().trim().split(" ")[0];
                        varNams[i] = matcher2.group(1).toString().trim().split(" ")[1];
                        varVals[i] = matcher2.group(2).toString().trim();
                        if (varNeedBind != null && varNeedBind.contains(varVals[i]))
                            monitoredPC.put(varVals[i], varNams[i]);
                        varVals[i] = "$$" + varVals[i];
                    }
                }
            }
            if (monitorVal != null && monitorVal.length() > 0)
                jOut(1, "Object around(%s): %s(%s) {", aroundlist, pointcutName, arglist);
            else
                jOut(1, "Object around(): %s() {", pointcutName);

            jOut(2, "Object ret = null;");
            String[] conditionState = genCoditionStatements(varTyps, varNams, varVals);
            if (conditionState != null && conditionState[0] != null && conditionState[0].length() > 0) {
                jOut(2, "if (" + conditionState[0] + ") {");

                if (conditionState[1] != null && conditionState[1].length() > 0) {
                    String[] updates = conditionState[1].split("&&");
                    for (String str : updates)
                        jOut(3, str);
                }
                outAdviceProlog4DynBind(3,0);

                if (mode == 0) { //monitor the action
                    jOut(3, "root.queryAction(new Event(thisJoinPoint));");
                    jOut(3, "ret = proceed(%s);", arglist);
                    outAdviceProlog4DynBind(3, 1);
                    jOut(2, "}");
                    jOut(2, "else  ret = proceed(%s);", arglist);
                    jOut(2, "return ret;");
                } else { //if(mode == 1  || mode ==2) { // monitor the result
                    jOut(3, "ret = proceed(%s);", arglist);
                    outAdviceProlog4DynBind(3, 1);
                    jOut(3, "Event event = new Event(thisJoinPoint);");
                    jOut(3, "event.setEventType(\"Result\");");
                    jOut(3, "event.setResult(ret);");
                    jOut(3, "root.queryAction(event);");
                    jOut(3, "return ret;");
                    jOut(2, "}");
                    jOut(2, "else   return proceed(%s);", arglist);
                }
            } else {
                outAdviceProlog4DynBind(2,0);
                jOut(2, "root.queryAction(new Event(thisJoinPoint));");
                outAdviceProlog4DynBind(2, 1);
                jOut(2, "return proceed(%s);", arglist);
            }
            jOut(1, "}\n");

            //need generate the before advice for the case need monitor before and after of one method
            if (mode == 2) {
                if (monitorVal != null && monitorVal.length() > 0)
                    jOut(1, "before(%s): %s(%s) {", aroundlist, pointcutName, arglist);
                else
                    jOut(1, "before(): %s() {", pointcutName);

                if (conditionState != null && conditionState[0] != null && conditionState[0].length() > 0) {
                    jOut(2, "if (" + conditionState[0] + ") {");
                    if (conditionState[1] != null && conditionState[1].length() > 0) {
                        String[] updates = conditionState[1].split("&&");
                        for (String str : updates)
                            jOut(3, str);
                    }
                    outAdviceProlog4DynBind(3,0);
                    jOut(3, "root.queryAction(new Event(thisJoinPoint));");
                    outAdviceProlog4DynBind(3,1);
                    jOut(3, "return;");
                    jOut(2, "}");
                    jOut(2, "else   return;");
                } else {
                    outAdviceProlog4DynBind(2,0);
                    outAdviceProlog4DynBind(2,1);
                    jOut(3, "return;");
                }
                jOut(1, "}\n");
            }
        } else {
            if (monitorVal != null && monitorVal.length() > 0)
                jOut(1, "Object around(%s): %s(%s) {", aroundlist, pointcutName, arglist);
            else
                jOut(1, "Object around(): %s() {", pointcutName);
            if (mode == 0) { //monitor the action
                outAdviceProlog4DynBind(2,0);
                jOut(2, "root.queryAction(new Event(thisJoinPoint));");
                jOut(2, "return proceed();");
            } else {
                outAdviceProlog4DynBind(2,0);
                jOut(2, "Object ret = proceed();", arglist);
                outAdviceProlog4DynBind(2,1);
                jOut(2, "Event event = new Event(thisJoinPoint);");
                jOut(2, "event.setEventType(\"Result\");");
                jOut(2, "event.setResult(ret);");
                jOut(2, "root.queryAction(event);");
                jOut(2, "return event.getResult();");
            }
            jOut(1, "}\n");
        }
    }

    private String[] genCoditionStatements(String[] varTyps, String[] varNams, String[] varVals) {
        if (varTyps == null || varTyps.length == 0)
            return null;
        else {
            String[] returnStr = new String[2];
            returnStr[0] = "";
            returnStr[1] = "";
            String[] temp = new String[2];
            for (int i = 0; i < varTyps.length; i++) {
                //need handle the case where we do not care about the type and value
                if (varVals[i] == null) {
                    continue;
                }
                if (varVals[i].startsWith("$$") && !varVals[i].startsWith("$$$"))
                    temp = genCoditionStatement(varTyps[i], varNams[i],
                            varVals[i].substring(2, varVals[i].length()), 1);
                else
                    temp = genCoditionStatement(varTyps[i], varNams[i], varVals[i], 0);
                if (temp != null) {
                    if (temp[0] != null)
                        returnStr[0] += temp[0] + " && ";
                    if (temp[1] != null)
                        returnStr[1] += temp[1] + " && ";
                }
            }
            returnStr[0] = trimLastPunctuation(returnStr[0], " && ");
            returnStr[1] = trimLastPunctuation(returnStr[1], " && ");
            return returnStr;
        }
    }

    private String[] genCoditionStatement(String type, String valName, String matchVal, int mode) {
        String[] resultStr = new String[2];
        if (matchVal != null && matchVal.length() > 0) {
            matchVal = matchVal.replace("%", ".*");
            if (monitoredPC.contains(matchVal))
                resultStr[1] = matchVal + " = " + valName + ";";
            String str = "";
            switch (type) {
                case "int":
                case "short":
                    str = "new Integer(" + valName + ").toString()";
                    break;
                case "long":
                case "double":
                    str = "String.valueOf(" + valName + ")";
                    break;
                case "float":
                    str = "Float.toString(" + valName + ")";
                    break;
                case "boolean":
                    str = "Boolean.toString(" + valName + ")";
                    break;
                case "char":
                    str = "Character.toString(" + valName + ")";
                    break;
                default:
                    str = "String.valueOf(" + valName + ")";
            }
            if (mode == 0)
                resultStr[0] = "SREUtil.StringMatch(" + str + ", \"" + matchVal + "\")";
            else //if(mode == 1)
                resultStr[0] = "SREUtil.StringMatch(" + str + ", DataWH.closure.get(\"" + matchVal + "\"))";
            return resultStr;
        }
        return null;
    }

    private void outAdvicePrologue4Result(String pointcutName) {
        jOut(1, "Object around(Method run): %s(run) {", pointcutName);
        jOut(2, "String className = SREUtil.trimClassName(run.getDeclaringClass().toString());");
        jOut(2, "className =SREUtil.concatClsMethod(className, run.getName());\n");
        jOut(2, "if (matchingStack(className)) {");
        jOut(3, "Object ret = proceed(run);");
        jOut(3, "Event event = new Event(thisJoinPoint);");
        jOut(3, "event.setEventType(\"Result\");");
        jOut(3, "String methodName = run.getDeclaringClass().toString()+\".\"+run.getName();");
        jOut(3, "if (methodName.startsWith(\"class \"))");
        jOut(4, "methodName = methodName.substring(6,methodName.length());");
        jOut(3, "event.setPromotedMethod(methodName);");
        jOut(3, "event.setResult(ret);");
        jOut(3, "root.queryAction(event);");
        jOut(3, "return ret;");
        jOut(2, "}");
        jOut(2, "else");
        jOut(3, "return proceed(run);");
        jOut(1, "}\n");
    }

    private void outAdviceProlog4DynBind(int offset, int mode) {
        if(mode ==0) {
            if (monitoredPC != null && monitoredPC.size() > 0) {
                Set<String> set = monitoredPC.keySet();
                jOut(offset, "String typeVal; ");
                for (Iterator<String> it = set.iterator(); it.hasNext(); ) {
                    String varName = it.next();
                    if (varNeedBind.contains(varName))
                        varNeedBind.remove(varName);
                    jOut(offset, "typeVal = DataWH.dataVal.get(\"" + varName + "\").getType();");
                    jOut(offset, "DataWH.dataVal.remove(\"" + varName + "\");");
                    jOut(offset, "DataWH.dataVal.put(\"" + varName + "\", new TypeVal(typeVal, " + monitoredPC.get(varName) + "));");
                }
            }
        }else {
            if (varNeedBind != null) {
                for (String str : varNeedBind) {
                    jOut(offset, "if(DataWH.dataVal.get(\"" + str + "\")!=null) {");
                    jOut(offset+1, "String typeVal;");
                    jOut(offset+1, "typeVal = DataWH.dataVal.get(\"" + str + "\").getType();");
                    jOut(offset+1, "DataWH.dataVal.remove(\"" + str + "\");");
                    jOut(offset+1, "DataWH.dataVal.put(\"" + str + "\", new TypeVal(typeVal, ret));");
                    jOut(offset, "}");
                }
            }
        }
    }

    public static void main(String[] args) {
        Compiler compiler = new Compiler(args);
        compiler.compile();
    }

    /**
     * This method is used to generate the method name for Pointcut
     */
    private String getPCMethodName(String str) {
        int begingIndex = str.indexOf("(", 0);
        if (begingIndex != -1)
            return str.substring(0, begingIndex);
        return str;
    }

    private String[] getArgsLstArray(String str) {
        // File.new(String$*.class$)(int$1$)   || FileWriter.new($$ext)
        String argList = "";
        int index = str.indexOf('(', 0);
        while (index != -1) {
            int index2 = str.indexOf(')', 0);
            if (index2 > index) {
                argList += str.substring(index + 1, index2) + ",";
                if (index2 + 1 < str.length()) {
                    str = str.substring(index2 + 1, str.length());
                    index = str.indexOf('(', 0);
                } else
                    break;
            } else
                break;
        }
        if (argList.length() > 0)
            return argList.split(",");
        else return null;
    }

    /**
     * This function return either arg type or arg value
     *
     * @param str
     * @param index == 1 return args Type; index == 2 return value
     * @return
     */
    private String getArgsType(String str, int index) {
        //java.lang.String$$*.class$$ || int$$1$$ || $$ip ||java.lang.String
        String reg = "(.+)(\\$\\$\\$(.+)\\$\\$\\$)";
        Pattern pattern = Pattern.compile(reg);
        Matcher matcher = pattern.matcher(str);
        if (matcher.find())
            return matcher.group(index).toString().trim();
        else {
            reg = "\\$\\$(.+)\\$\\$";
            pattern = Pattern.compile(reg);
            matcher = pattern.matcher(str);
            if (matcher.find()) {
                String temp = matcher.group(1).toString().trim();
                if (index == 1) {
                    if (temp.endsWith("$$"))
                        temp = temp.substring(0, temp.length() - 2);
                    String varType = closure.getType(temp).trim();
                    if (varType == null || varType.length() == 0)
                        return "java.lang.String";
                    else
                        return varType;
                } else { //if index == 2;
                    String value = closure.getContext(temp);
                    if (value == null)
                        return "$$" + temp.trim() + "$$";
                    else
                        return "$$$" + value.trim() + "$$$";
                }
            }
        }
        if (index == 1) {
            if (str.trim().equals("\\*"))
                return "..";
            return str.trim();
        } else
            return null;
    }

    /**
     * This method is used to draw parameter types of the method, so that
     * pointcut can correctly monitor the correct method.
     *
     * @param argStr
     * @return method signature
     */
    private String getArgsTyp4PC(String argStr) {
        //(java.lang.String$$*.class$$)
        //(\*)(java.lang.String$$*.class$$)
        String returnStr = "";
        if (argStr != null && argStr.length() > 0) {
            String[] args = argStr.split("[()]+");
            if (args != null) {
                for (int i = 0; i < args.length; i++) {
                    if (args[i].trim().length() == 0) continue;
                    returnStr += getArgsType(args[i].trim(), 1);
                    if (i != args.length - 1)
                        returnStr += ",";
                }
            }
        }
        return returnStr;
    }

    private void genVarClosure(String aspectName) {
        Set<Map.Entry<String, VarTypeVal>> entrySet = closure.getClosures().entrySet();
        //if both empty no need for gening constructor
        if((entrySet== null||entrySet.size()<=1) && (objParams== null||entrySet.size() ==0))
            return;
        jOut(1, "public " + aspectName + "() {");
        for (Map.Entry entry : entrySet) {
            if (entry.getKey().equals("PolicyName"))
                continue;
            String varContext = ((VarTypeVal) entry.getValue()).getVarContext();
            if (varContext == null || varContext.equals("%"))
                varContext = ".*";
            if (varContext.contains("%."))
                varContext = varContext.replace("%.", "(.*)\\.");
            varContext = varContext.replace("\\", "\\\\");
            jOut(2, "DataWH.closure.put(\"" + entry.getKey() + "\", \"" + varContext + "\");");
        }
        if (objParams != null) {
            for (String s : objParams) {
                String varType = "";
                String varContext = "";
                VarTypeVal varTypeVal = (VarTypeVal) closure.getClosures().get(s);
                if (varTypeVal != null) {
                    varType = varTypeVal.getVarType();
                    varContext = varTypeVal.getVarContext();
                }
                if (varType == null || varType.equals(""))
                    varType = "java.lang.String";
                if (varContext == null || varContext.equals("%")) {
                    if (varType.equals("java.lang.String"))
                        varContext = ".*";
                    else
                        varContext = "null";
                }
                if (varContext.contains("%."))
                    varContext = varContext.replace("%.", "(.*)\\.");
                varContext = varContext.replace("\\", "\\\\");
                String str = "new TypeVal(\"" + varType + "\",  null));";
                if (!varContext.equals("null")) {
                    switch (varType) {
                        case "int":
                            str = "new TypeVal(\"java.lang.String\",\"" + varContext + "\"));";
                            break;
                        case "short":
                            str = "new TypeVal(\"short\",new Integer(\"" + varContext + "\")));";
                            break;
                        case "long":
                            str = "new TypeVal(\"long\",new Long(\"" + varContext + "\")));";
                            break;
                        case "double":
                            str = "new TypeVal(\"double\",new Double(\"" + varContext + "\")));";
                            break;
                        case "float":
                            str = "new TypeVal(\"float\",new Float(\"" + varContext + "\")));";
                            break;
                        case "boolean":
                            str = "new TypeVal(\"boolean\",new Boolean(\"" + varContext + "\")));";
                            break;
                        case "char":
                            str = "new TypeVal(\"char\",new Character(" + varContext + ".CharAt(0))));";
                            break;
                        case "String":
                        case "java.lang.String":
                            str = "new TypeVal(\"java.lang.String\", \"" + varContext + "\"));";
                            break;
                        case "Message":
                        case "javax.mail.Message":
                            str = "new TypeVal(\"java.lang.String\",  null));";
                            break;
                    }
                }
                jOut(2, "DataWH.dataVal.put(\"" + s + "\"," + str);
            }
        }
        jOut(1, "}");
    }
}